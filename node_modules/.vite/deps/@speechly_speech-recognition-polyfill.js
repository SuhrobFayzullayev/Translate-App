import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-J43GMYXM.js";

// node_modules/@speechly/browser-client/core/speechly.es.js
var speechly_es_exports = {};
__export(speechly_es_exports, {
  AudioSourceState: () => AudioSourceState,
  BrowserClient: () => BrowserClient,
  BrowserMicrophone: () => BrowserMicrophone,
  CloudDecoder: () => CloudDecoder,
  ControllerSignal: () => ControllerSignal,
  DecoderDefaultOptions: () => DecoderDefaultOptions,
  DecoderState: () => DecoderState,
  DefaultSampleRate: () => DefaultSampleRate,
  ErrAlreadyInitialized: () => ErrAlreadyInitialized,
  ErrAlreadyStarted: () => ErrAlreadyStarted,
  ErrAlreadyStopped: () => ErrAlreadyStopped,
  ErrAppIdChangeWithoutProjectLogin: () => ErrAppIdChangeWithoutProjectLogin,
  ErrDeviceNotSupported: () => ErrDeviceNotSupported,
  ErrKeyNotFound: () => ErrKeyNotFound,
  ErrNoAudioConsent: () => ErrNoAudioConsent,
  ErrNoStorageSupport: () => ErrNoStorageSupport,
  ErrNotInitialized: () => ErrNotInitialized,
  EventCallbacks: () => EventCallbacks,
  ListenerArray: () => ListenerArray,
  SegmentState: () => SegmentState,
  StreamDefaultOptions: () => StreamDefaultOptions,
  VadDefaultOptions: () => VadDefaultOptions,
  WebsocketResponseType: () => WebsocketResponseType,
  WorkerSignal: () => WorkerSignal,
  stateToString: () => stateToString
});
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function stateToString(state) {
  var _a;
  return (_a = states.get(state)) !== null && _a !== void 0 ? _a : "unknown";
}
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== "undefined" && typeof msCrypto.getRandomValues === "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
function validate(uuid) {
  return typeof uuid === "string" && REGEX.test(uuid);
}
function stringify(arr) {
  var offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  if (!validate(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
function v4(options, buf, offset) {
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return stringify(rnds);
}
function fetchToken(baseUrl, projectId, appId, deviceId, fetcher = fetch, nowFn = Date.now) {
  var _a;
  return __awaiter(this, void 0, void 0, function* () {
    let body;
    if (projectId !== void 0) {
      body = { projectId, deviceId };
    } else {
      body = { appId, deviceId };
    }
    const response = yield fetcher(baseUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body)
    });
    const json = yield response.json();
    if (response.status !== 200) {
      throw Error((_a = json.error) !== null && _a !== void 0 ? _a : `Speechly API login request failed with ${response.status}`);
    }
    if (json.access_token === void 0) {
      throw Error("Invalid login response from Speechly API");
    }
    if (!validateToken(json.access_token, projectId, appId, deviceId, nowFn)) {
      throw Error("Invalid token received from Speechly API");
    }
    return json.access_token;
  });
}
function validateToken(token, projectId, appId, deviceId, now = Date.now) {
  const decoded = decodeToken(token);
  if (decoded.expiresAtMs - now() < minTokenValidTime) {
    return false;
  }
  if (decoded.appId !== appId || decoded.projectId !== projectId) {
    return false;
  }
  if (decoded.deviceId !== deviceId) {
    return false;
  }
  return true;
}
function decodeToken(token) {
  const b = token.split(".")[1];
  let body;
  try {
    body = JSON.parse(base64.exports.decode(b));
  } catch (e) {
    throw new Error("Error decoding Speechly token!");
  }
  return {
    appId: body.appId,
    projectId: body.projectId,
    deviceId: body.deviceId,
    configId: body.configId,
    scopes: body.scope.split(" "),
    issuer: body.iss,
    audience: body.aud,
    expiresAtMs: body.exp * 1e3
  };
}
function decodeBase64(base642, enableUnicode) {
  var binaryString = atob(base642);
  if (enableUnicode) {
    var binaryView = new Uint8Array(binaryString.length);
    for (var i = 0, n = binaryString.length; i < n; ++i) {
      binaryView[i] = binaryString.charCodeAt(i);
    }
    return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
  }
  return binaryString;
}
function createURL(base642, sourcemapArg, enableUnicodeArg) {
  var sourcemap = sourcemapArg === void 0 ? null : sourcemapArg;
  var enableUnicode = enableUnicodeArg === void 0 ? false : enableUnicodeArg;
  var source = decodeBase64(base642, enableUnicode);
  var start = source.indexOf("\n", 10) + 1;
  var body = source.substring(start) + (sourcemap ? "//# sourceMappingURL=" + sourcemap : "");
  var blob = new Blob([body], { type: "application/javascript" });
  return URL.createObjectURL(blob);
}
function createBase64WorkerFactory(base642, sourcemapArg, enableUnicodeArg) {
  var url;
  return function WorkerFactory2(options) {
    url = url || createURL(base642, sourcemapArg, enableUnicodeArg);
    return new Worker(url, options);
  };
}
function parseTentativeTranscript(data, timeOffset) {
  return data.words.map(({ word, index, start_timestamp, end_timestamp }) => {
    return {
      value: word,
      index,
      startTimestamp: start_timestamp + timeOffset,
      endTimestamp: end_timestamp + timeOffset,
      isFinal: false
    };
  });
}
function parseTranscript(data, timeOffset) {
  return {
    value: data.word,
    index: data.index,
    startTimestamp: data.start_timestamp + timeOffset,
    endTimestamp: data.end_timestamp + timeOffset,
    isFinal: true
  };
}
function parseTentativeEntities(data) {
  return data.entities.map(({ entity, value, start_position, end_position }) => {
    return {
      type: entity,
      value,
      startPosition: start_position,
      endPosition: end_position,
      isFinal: false
    };
  });
}
function parseEntity(data) {
  return {
    type: data.entity,
    value: data.value,
    startPosition: data.start_position,
    endPosition: data.end_position,
    isFinal: true
  };
}
function parseIntent(data, isFinal) {
  return {
    intent: data.intent,
    isFinal
  };
}
function generateWsUrl(baseUrl, sampleRate) {
  const params = new URLSearchParams();
  params.append("sampleRate", sampleRate.toString());
  return `${baseUrl}?${params.toString()}`;
}
function iOS() {
  const iosPlatforms = ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"];
  return iosPlatforms.indexOf(navigator.platform) >= 0 || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
var ErrDeviceNotSupported, ErrAppIdChangeWithoutProjectLogin, DefaultSampleRate, SegmentState, ErrNotInitialized, ErrAlreadyInitialized, ErrNoAudioConsent, AudioSourceState, BrowserMicrophone, WebsocketResponseType, WorkerSignal, ControllerSignal, ErrNoStorageSupport, ErrKeyNotFound, DecoderDefaultOptions, VadDefaultOptions, StreamDefaultOptions, DecoderState, ListenerArray, EventCallbacks, ErrAlreadyStarted, ErrAlreadyStopped, states, getRandomValues, rnds8, REGEX, byteToHex, i, commonjsGlobal, base64, minTokenValidTime, WorkerFactory, WebWorkerController, LocalStorage, deviceIdStorageKey, authTokenKey, CloudDecoder, audioworklet, BrowserClient;
var init_speechly_es = __esm({
  "node_modules/@speechly/browser-client/core/speechly.es.js"() {
    ErrDeviceNotSupported = new Error("Current device does not support microphone API");
    ErrAppIdChangeWithoutProjectLogin = new Error("AppId changed without project login");
    DefaultSampleRate = 16e3;
    SegmentState = class {
      constructor(contextId, segmentIndex) {
        this.isFinalized = false;
        this.words = [];
        this.entities = /* @__PURE__ */ new Map();
        this.intent = { intent: "", isFinal: false };
        this.contextId = contextId;
        this.id = segmentIndex;
      }
      toSegment() {
        let i = 0;
        const entities = new Array(this.entities.size);
        this.entities.forEach((v) => {
          entities[i] = v;
          i++;
        });
        return {
          id: this.id,
          contextId: this.contextId,
          isFinal: this.isFinalized,
          words: this.words,
          entities,
          intent: this.intent
        };
      }
      toString() {
        const segment = this.toSegment();
        const words = segment.words.filter((w) => w.value);
        const cleanSegment = Object.assign(Object.assign({}, segment), { words });
        return JSON.stringify(cleanSegment, null, 2);
      }
      updateTranscript(words) {
        words.forEach((w) => {
          if (!this.isFinalized || w.isFinal) {
            this.words[w.index] = w;
          }
        });
        return this;
      }
      updateEntities(entities) {
        entities.forEach((e) => {
          if (!this.isFinalized || e.isFinal) {
            this.entities.set(this.entityMapKey(e), e);
          }
        });
        return this;
      }
      updateIntent(intent) {
        if (!this.isFinalized || intent.isFinal) {
          this.intent = intent;
        }
        return this;
      }
      finalize() {
        this.entities.forEach((val, key) => {
          if (!val.isFinal) {
            this.entities.delete(key);
          }
        });
        this.words = this.words.filter((w) => w.isFinal);
        if (!this.intent.isFinal) {
          this.intent.intent = "";
          this.intent.isFinal = true;
        }
        this.isFinalized = true;
        return this;
      }
      entityMapKey(e) {
        return `${e.startPosition.toString()}:${e.endPosition.toString()}`;
      }
    };
    ErrNotInitialized = new Error("Microphone is not initialized");
    ErrAlreadyInitialized = new Error("Microphone is already initialized");
    ErrNoAudioConsent = new Error("Microphone consent is not given");
    (function(AudioSourceState2) {
      AudioSourceState2["NoAudioConsent"] = "NoAudioConsent";
      AudioSourceState2["NoBrowserSupport"] = "NoBrowserSupport";
      AudioSourceState2["Stopped"] = "Stopped";
      AudioSourceState2["Starting"] = "Starting";
      AudioSourceState2["Started"] = "Started";
    })(AudioSourceState || (AudioSourceState = {}));
    BrowserMicrophone = class {
      constructor() {
        this.muted = false;
        this.initialized = false;
        this.state = AudioSourceState.Stopped;
        this.debug = false;
        this.stateChangeCbs = [];
        try {
          const constraints = window.navigator.mediaDevices.getSupportedConstraints();
          this.nativeResamplingSupported = constraints.sampleRate === true;
          this.autoGainControlSupported = constraints.autoGainControl === true;
        } catch (_a) {
          this.nativeResamplingSupported = false;
          this.autoGainControlSupported = false;
        }
      }
      onStateChange(cb) {
        this.stateChangeCbs.push(cb);
      }
      initialize() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          if (this.initialized) {
            return;
          }
          if (((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.mediaDevices) === void 0) {
            this.setState(AudioSourceState.NoBrowserSupport);
            throw ErrDeviceNotSupported;
          }
          const mediaStreamConstraints = {
            video: false
          };
          if (this.nativeResamplingSupported || this.autoGainControlSupported) {
            mediaStreamConstraints.audio = {
              sampleRate: DefaultSampleRate,
              autoGainControl: this.autoGainControlSupported
            };
          } else {
            mediaStreamConstraints.audio = true;
          }
          try {
            this.setState(AudioSourceState.Starting);
            this.mediaStream = yield window.navigator.mediaDevices.getUserMedia(mediaStreamConstraints);
          } catch (err) {
            this.setState(AudioSourceState.NoAudioConsent);
            console.error(err);
            throw ErrNoAudioConsent;
          }
          this.initialized = true;
          this.muted = true;
          this.setState(AudioSourceState.Started);
        });
      }
      setState(newState) {
        if (this.state === newState) {
          return;
        }
        if (this.debug) {
          console.log("[BrowserMicrophone]", this.state, "->", newState);
        }
        this.state = newState;
        this.stateChangeCbs.forEach((cb) => cb(newState));
      }
      close() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.initialized)
            return;
          this.muted = true;
          const stream = this.mediaStream;
          stream.getTracks().forEach((t) => t.stop());
          this.mediaStream = void 0;
          this.initialized = false;
          this.setState(AudioSourceState.Stopped);
        });
      }
      isRecording() {
        return !this.muted;
      }
    };
    (function(WebsocketResponseType2) {
      WebsocketResponseType2["Started"] = "started";
      WebsocketResponseType2["Stopped"] = "stopped";
      WebsocketResponseType2["SegmentEnd"] = "segment_end";
      WebsocketResponseType2["Transcript"] = "transcript";
      WebsocketResponseType2["Entity"] = "entity";
      WebsocketResponseType2["Intent"] = "intent";
      WebsocketResponseType2["TentativeTranscript"] = "tentative_transcript";
      WebsocketResponseType2["TentativeEntities"] = "tentative_entities";
      WebsocketResponseType2["TentativeIntent"] = "tentative_intent";
    })(WebsocketResponseType || (WebsocketResponseType = {}));
    (function(WorkerSignal2) {
      WorkerSignal2["Opened"] = "WEBSOCKET_OPEN";
      WorkerSignal2["Closed"] = "WEBSOCKET_CLOSED";
      WorkerSignal2["AudioProcessorReady"] = "SOURCE_SAMPLE_RATE_SET_SUCCESS";
      WorkerSignal2["VadSignalHigh"] = "VadSignalHigh";
      WorkerSignal2["VadSignalLow"] = "VadSignalLow";
      WorkerSignal2["RequestContextStart"] = "RequestContextStart";
    })(WorkerSignal || (WorkerSignal = {}));
    (function(ControllerSignal2) {
      ControllerSignal2["connect"] = "connect";
      ControllerSignal2["initAudioProcessor"] = "initAudioProcessor";
      ControllerSignal2["adjustAudioProcessor"] = "adjustAudioProcessor";
      ControllerSignal2["SET_SHARED_ARRAY_BUFFERS"] = "SET_SHARED_ARRAY_BUFFERS";
      ControllerSignal2["CLOSE"] = "CLOSE";
      ControllerSignal2["START_CONTEXT"] = "START_CONTEXT";
      ControllerSignal2["SWITCH_CONTEXT"] = "SWITCH_CONTEXT";
      ControllerSignal2["STOP_CONTEXT"] = "STOP_CONTEXT";
      ControllerSignal2["AUDIO"] = "AUDIO";
      ControllerSignal2["startStream"] = "startStream";
      ControllerSignal2["stopStream"] = "stopStream";
      ControllerSignal2["setContextOptions"] = "setContextOptions";
    })(ControllerSignal || (ControllerSignal = {}));
    ErrNoStorageSupport = new Error("Current device does not support storage API");
    ErrKeyNotFound = new Error("Requested key was not present in storage");
    DecoderDefaultOptions = {
      connect: true,
      apiUrl: "https://api.speechly.com",
      sampleRate: DefaultSampleRate,
      debug: false,
      logSegments: false,
      frameMillis: 30,
      historyFrames: 5
    };
    VadDefaultOptions = {
      enabled: false,
      controlListening: true,
      signalToNoiseDb: 3,
      noiseGateDb: -24,
      noiseLearnHalftimeMillis: 400,
      signalSearchFrames: 5,
      signalActivation: 0.7,
      signalRelease: 0.2,
      signalSustainMillis: 3e3
    };
    StreamDefaultOptions = {
      preserveSegments: false,
      sampleRate: DefaultSampleRate,
      immediate: false,
      autoStarted: false
    };
    (function(DecoderState2) {
      DecoderState2[DecoderState2["Failed"] = 0] = "Failed";
      DecoderState2[DecoderState2["Disconnected"] = 1] = "Disconnected";
      DecoderState2[DecoderState2["Connected"] = 2] = "Connected";
      DecoderState2[DecoderState2["Active"] = 3] = "Active";
    })(DecoderState || (DecoderState = {}));
    ListenerArray = class extends Array {
      addEventListener(e) {
        this.push(e);
      }
      removeEventListener(e) {
        const index = this.findIndex((cb) => cb === e);
        if (index >= 0) {
          this.splice(index, 1);
        }
      }
    };
    EventCallbacks = class {
      constructor() {
        this.stateChangeCbs = new ListenerArray();
        this.transcriptCbs = new ListenerArray();
        this.entityCbs = new ListenerArray();
        this.intentCbs = new ListenerArray();
        this.segmentChangeCbs = new ListenerArray();
        this.tentativeTranscriptCbs = new ListenerArray();
        this.tentativeEntityCbs = new ListenerArray();
        this.tentativeIntentCbs = new ListenerArray();
        this.contextStartedCbs = new ListenerArray();
        this.contextStoppedCbs = new ListenerArray();
        this.onVadStateChange = new ListenerArray();
      }
    };
    ErrAlreadyStarted = new Error("BrowserClient already started");
    ErrAlreadyStopped = new Error("BrowserClient already stopped");
    states = /* @__PURE__ */ new Map([
      [DecoderState.Failed, "Failed"],
      [DecoderState.Disconnected, "Disconnected"],
      [DecoderState.Connected, "Connected"],
      [DecoderState.Active, "Active"]
    ]);
    rnds8 = new Uint8Array(16);
    REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    base64 = { exports: {} };
    (function(module, exports) {
      (function(root) {
        var freeExports = exports;
        var freeModule = module && module.exports == freeExports && module;
        var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
          root = freeGlobal;
        }
        var InvalidCharacterError = function(message) {
          this.message = message;
        };
        InvalidCharacterError.prototype = new Error();
        InvalidCharacterError.prototype.name = "InvalidCharacterError";
        var error = function(message) {
          throw new InvalidCharacterError(message);
        };
        var TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g;
        var decode = function(input) {
          input = String(input).replace(REGEX_SPACE_CHARACTERS, "");
          var length = input.length;
          if (length % 4 == 0) {
            input = input.replace(/==?$/, "");
            length = input.length;
          }
          if (length % 4 == 1 || /[^+a-zA-Z0-9/]/.test(input)) {
            error(
              "Invalid character: the string to be decoded is not correctly encoded."
            );
          }
          var bitCounter = 0;
          var bitStorage;
          var buffer;
          var output = "";
          var position = -1;
          while (++position < length) {
            buffer = TABLE.indexOf(input.charAt(position));
            bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;
            if (bitCounter++ % 4) {
              output += String.fromCharCode(
                255 & bitStorage >> (-2 * bitCounter & 6)
              );
            }
          }
          return output;
        };
        var encode = function(input) {
          input = String(input);
          if (/[^\0-\xFF]/.test(input)) {
            error(
              "The string to be encoded contains characters outside of the Latin1 range."
            );
          }
          var padding = input.length % 3;
          var output = "";
          var position = -1;
          var a;
          var b;
          var c;
          var buffer;
          var length = input.length - padding;
          while (++position < length) {
            a = input.charCodeAt(position) << 16;
            b = input.charCodeAt(++position) << 8;
            c = input.charCodeAt(++position);
            buffer = a + b + c;
            output += TABLE.charAt(buffer >> 18 & 63) + TABLE.charAt(buffer >> 12 & 63) + TABLE.charAt(buffer >> 6 & 63) + TABLE.charAt(buffer & 63);
          }
          if (padding == 2) {
            a = input.charCodeAt(position) << 8;
            b = input.charCodeAt(++position);
            buffer = a + b;
            output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 63) + TABLE.charAt(buffer << 2 & 63) + "=";
          } else if (padding == 1) {
            buffer = input.charCodeAt(position);
            output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 63) + "==";
          }
          return output;
        };
        var base642 = {
          "encode": encode,
          "decode": decode,
          "version": "0.1.0"
        };
        if (freeExports && !freeExports.nodeType) {
          if (freeModule) {
            freeModule.exports = base642;
          } else {
            for (var key in base642) {
              base642.hasOwnProperty(key) && (freeExports[key] = base642[key]);
            }
          }
        } else {
          root.base64 = base642;
        }
      })(commonjsGlobal);
    })(base64, base64.exports);
    minTokenValidTime = 60 * 60 * 1e3;
    WorkerFactory = createBase64WorkerFactory("Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwp2YXIgd29ya2VyX2NvZGUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHsKICAgICd1c2Ugc3RyaWN0JzsKCiAgICAvKioKICAgICAqIEBpbnRlcm5hbAogICAgICovCiAgICBjbGFzcyBBdWRpb1Rvb2xzIHsKICAgICAgICBzdGF0aWMgZG93bnNhbXBsZShzcmMsIGRlc3QsIHNvdXJjZUluZGV4ID0gMCwgc291cmNlTGVuZ3RoID0gLTEsIGRlc3RJbmRleCA9IDAsIGRlc3RMZW5ndGggPSAtMSkgewogICAgICAgICAgICBpZiAoc291cmNlTGVuZ3RoIDwgMCkKICAgICAgICAgICAgICAgIHNvdXJjZUxlbmd0aCA9IHNyYy5sZW5ndGggLSBzb3VyY2VJbmRleDsKICAgICAgICAgICAgaWYgKGRlc3RMZW5ndGggPCAwKQogICAgICAgICAgICAgICAgZGVzdExlbmd0aCA9IGRlc3QubGVuZ3RoIC0gZGVzdEluZGV4OwogICAgICAgICAgICBpZiAoZGVzdExlbmd0aCA+IHNvdXJjZUxlbmd0aCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBkb3duc2FtcGxlOiBzb3VyY2UgYXJyYXkgbGVuZ3RoICgke3NvdXJjZUxlbmd0aH0pIGlzIHNob3J0ZXIgdGhhbiBkZXN0aW5hdGlvbiAoJHtkZXN0TGVuZ3RofSlgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZGVzdExlbmd0aCA9PT0gMCkgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBkb3duc2FtcGxlOiBzb3VyY2UgYXJyYXkgbGVuZ3RoICgke3NvdXJjZUxlbmd0aH0pIGNhbid0IGJlIGRvd25zYW1wbGVkIHRvIHplcm8tbGVuZ3RoIGRlc3RpbmF0aW9uLmApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzb3VyY2VMZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigiQ2FuJ3QgZG93bnNhbXBsZTogc291cmNlIHJhbmdlIGNhbid0IGJlIHplcm8gbGVuZ3RoLiIpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChzb3VyY2VMZW5ndGggPT09IDEpIHsKICAgICAgICAgICAgICAgIGRlc3RbMF0gPSBzcmNbMF07CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGV0IGRlc3RJbmRleEZyYWN0aW9uID0gMC4wOwogICAgICAgICAgICBjb25zdCBkZXN0U3RlcCA9IChkZXN0TGVuZ3RoIC0gMSkgLyAoc291cmNlTGVuZ3RoIC0gMSk7CiAgICAgICAgICAgIGxldCBzdW0gPSAwOwogICAgICAgICAgICBsZXQgdG90YWxXZWlnaHQgPSAwOwogICAgICAgICAgICBjb25zdCBzb3VyY2VFbmRJbmRleCA9IHNvdXJjZUluZGV4ICsgc291cmNlTGVuZ3RoOwogICAgICAgICAgICBmb3IgKDsgc291cmNlSW5kZXggPCBzb3VyY2VFbmRJbmRleDsgc291cmNlSW5kZXgrKykgewogICAgICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gMC41IC0gTWF0aC5hYnMoZGVzdEluZGV4RnJhY3Rpb24pOwogICAgICAgICAgICAgICAgc3VtICs9IHNyY1tzb3VyY2VJbmRleF0gKiB3ZWlnaHQ7CiAgICAgICAgICAgICAgICB0b3RhbFdlaWdodCArPSB3ZWlnaHQ7CiAgICAgICAgICAgICAgICBkZXN0SW5kZXhGcmFjdGlvbiArPSBkZXN0U3RlcDsKICAgICAgICAgICAgICAgIGlmIChkZXN0SW5kZXhGcmFjdGlvbiA+PSAwLjUpIHsKICAgICAgICAgICAgICAgICAgICBkZXN0SW5kZXhGcmFjdGlvbiAtPSAxOwogICAgICAgICAgICAgICAgICAgIGRlc3RbZGVzdEluZGV4KytdID0gc3VtIC8gdG90YWxXZWlnaHQ7CiAgICAgICAgICAgICAgICAgICAgc3VtID0gMDsKICAgICAgICAgICAgICAgICAgICB0b3RhbFdlaWdodCA9IDA7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gUHV0IGxhc3QgdmFsdWUgaW4gcGxhY2UKICAgICAgICAgICAgaWYgKHRvdGFsV2VpZ2h0ID4gMCkgewogICAgICAgICAgICAgICAgZGVzdFtkZXN0SW5kZXgrK10gPSBzdW0gLyB0b3RhbFdlaWdodDsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzdGF0aWMgZ2V0RW5lcmd5KHNhbXBsZXMsIHN0YXJ0ID0gMCwgbGVuZ3RoID0gLTEpIHsKICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDApCiAgICAgICAgICAgICAgICBsZW5ndGggPSBzYW1wbGVzLmxlbmd0aCAtIHN0YXJ0OwogICAgICAgICAgICBpZiAobGVuZ3RoIDw9IDApCiAgICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydCArIGxlbmd0aDsKICAgICAgICAgICAgbGV0IHN1bUVuZXJneVNxdWFyZWQgPSAwLjA7CiAgICAgICAgICAgIGZvciAoOyBzdGFydCA8IGVuZEluZGV4OyBzdGFydCsrKSB7CiAgICAgICAgICAgICAgICBzdW1FbmVyZ3lTcXVhcmVkICs9IHNhbXBsZXNbc3RhcnRdICogc2FtcGxlc1tzdGFydF07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIE1hdGguc3FydChzdW1FbmVyZ3lTcXVhcmVkIC8gbGVuZ3RoKTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGdldEF1ZGlvUGVhayhzYW1wbGVzLCBzdGFydCA9IDAsIGxlbmd0aCA9IC0xKSB7CiAgICAgICAgICAgIGlmIChsZW5ndGggPCAwKQogICAgICAgICAgICAgICAgbGVuZ3RoID0gc2FtcGxlcy5sZW5ndGggLSBzdGFydDsKICAgICAgICAgICAgaWYgKGxlbmd0aCA8PSAwKQogICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBsZW5ndGg7CiAgICAgICAgICAgIGxldCBwZWFrID0gMDsKICAgICAgICAgICAgZm9yICg7IHN0YXJ0IDwgZW5kSW5kZXg7IHN0YXJ0KyspIHsKICAgICAgICAgICAgICAgIGlmIChzYW1wbGVzW3N0YXJ0XSA+IHBlYWspIHsKICAgICAgICAgICAgICAgICAgICBwZWFrID0gc2FtcGxlc1tzdGFydF07CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIHBlYWs7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBjb252ZXJ0SW50MTZUb0Zsb2F0KHNyYywgZGVzdCwgc3JjU3RhcnRTYW1wbGUgPSAwLCBsZW5ndGhTYW1wbGVzID0gLTEsIGRzdEluZGV4ID0gMCkgewogICAgICAgICAgICBpZiAobGVuZ3RoU2FtcGxlcyA8IDApCiAgICAgICAgICAgICAgICBsZW5ndGhTYW1wbGVzID0gc3JjLmxlbmd0aCAvIDIgLSBzcmNTdGFydFNhbXBsZTsKICAgICAgICAgICAgY29uc3QgbWF4TGVuID0gTWF0aC5taW4oKHNyYy5sZW5ndGggLyAyKSAtIHNyY1N0YXJ0U2FtcGxlLCBkZXN0Lmxlbmd0aCAtIGRzdEluZGV4KTsKICAgICAgICAgICAgbGVuZ3RoU2FtcGxlcyA9IE1hdGgubWluKGxlbmd0aFNhbXBsZXMsIG1heExlbik7CiAgICAgICAgICAgIGlmIChsZW5ndGhTYW1wbGVzIDw9IDApCiAgICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgbGV0IGJ5dGVJbmRleCA9IHNyY1N0YXJ0U2FtcGxlICogMjsKICAgICAgICAgICAgY29uc3QgZW5kQnl0ZSA9IGJ5dGVJbmRleCArIGxlbmd0aFNhbXBsZXMgKiAyOwogICAgICAgICAgICB3aGlsZSAoYnl0ZUluZGV4IDwgZW5kQnl0ZSkgewogICAgICAgICAgICAgICAgZGVzdFtkc3RJbmRleCsrXSA9ICgoc3JjW2J5dGVJbmRleCsrXSArIChzcmNbYnl0ZUluZGV4KytdIDw8IDgpKSkgLyAweDdmZmY7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGxlbmd0aFNhbXBsZXM7CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBjb252ZXJ0RmxvYXRUb0ludDE2KHNyYywgZGVzdCwgc291cmNlSW5kZXggPSAwLCBzb3VyY2VMZW5ndGggPSAtMSwgZHN0SW5kZXggPSAwKSB7CiAgICAgICAgICAgIGlmIChzb3VyY2VMZW5ndGggPCAwKQogICAgICAgICAgICAgICAgc291cmNlTGVuZ3RoID0gc3JjLmxlbmd0aCAtIHNvdXJjZUluZGV4OwogICAgICAgICAgICBjb25zdCBlbmRJbmRleCA9IHNvdXJjZUluZGV4ICsgc291cmNlTGVuZ3RoOwogICAgICAgICAgICB3aGlsZSAoc291cmNlSW5kZXggPCBlbmRJbmRleCkgewogICAgICAgICAgICAgICAgZGVzdFtkc3RJbmRleCsrXSA9IH5+KHNyY1tzb3VyY2VJbmRleCsrXSAqIDB4N2ZmZik7IC8vIFF1aWNrIHRydW5jYXRlLCBubyByb3VuZGluZwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHN0YXRpYyBlbmVyZ3lUb0RiKGVuZXJneSkgewogICAgICAgICAgICByZXR1cm4gKDEwLjAgKiBNYXRoLmxvZyhlbmVyZ3kpIC8gQXVkaW9Ub29scy5MT0dfMl9QTFVTX0xPR181KTsKICAgICAgICB9CiAgICAgICAgc3RhdGljIGRiVG9FbmVyZ3koZGIpIHsKICAgICAgICAgICAgcmV0dXJuIE1hdGgucG93KDEwLjAsIGRiIC8gMTAuMCk7CiAgICAgICAgfQogICAgfQogICAgQXVkaW9Ub29scy5MT0dfMl9QTFVTX0xPR181ID0gTWF0aC5sb2coMikgKyBNYXRoLmxvZyg1KTsKCiAgICAvKioKICAgICAqIEBpbnRlcm5hbAogICAgICovCiAgICBjbGFzcyBBdWRpb1Byb2Nlc3NvciB7CiAgICAgICAgY29uc3RydWN0b3IoaW5wdXRTYW1wbGVSYXRlLCBvdXRwdXRTYW1wbGVSYXRlLCBmcmFtZU1pbGxpcywgaGlzdG9yeUZyYW1lcykgewogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogU2VuZGluZyBzdGF0ZS4gSWYgdHJ1ZSwgQXVkaW9Qcm9jZXNzb3IgaXMgY3VycmVudGx5IHNlbmRpbmcgYXVkaW8gdmlhIG9uU2VuZEF1ZGlvIGNhbGxiYWNrCiAgICAgICAgICAgICAqLwogICAgICAgICAgICB0aGlzLmlzU2VuZGluZyA9IGZhbHNlOwogICAgICAgICAgICAvKioKICAgICAgICAgICAgICogQ3VycmVudCBjb3VudCBvZiBkb3duc2FtcGxlZCBhbmQgY29udGludW91c2x5IHByb2Nlc3NlZCBzYW1wbGVzICh0aHJ1IFByb2Nlc3NBdWRpbykgZnJvbSBzdGFydCBvZiBzdHJlYW0KICAgICAgICAgICAgICovCiAgICAgICAgICAgIHRoaXMuc3RyZWFtU2FtcGxlUG9zID0gMDsKICAgICAgICAgICAgdGhpcy5zYW1wbGVzU2VudCA9IDA7CiAgICAgICAgICAgIHRoaXMudXR0ZXJhbmNlU2VyaWFsID0gLTE7CiAgICAgICAgICAgIHRoaXMub25TZW5kQXVkaW8gPSAoc2FtcGxlcywgc3RhcnRJbmRleCwgbGVuZ3RoKSA9PiB7IH07CiAgICAgICAgICAgIHRoaXMub25WYWRTdGF0ZUNoYW5nZSA9IChpc1NpZ25hbERldGVjdGVkKSA9PiB7IH07CiAgICAgICAgICAgIHRoaXMuaW5wdXRTYW1wbGVSYXRlID0gMTYwMDA7CiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTYW1wbGVSYXRlID0gMTYwMDA7CiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUZyYW1lcyA9IDU7CiAgICAgICAgICAgIHRoaXMuZnJhbWVNaWxsaXMgPSAzMDsKICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVOdW1iZXIgPSAwOwogICAgICAgICAgICB0aGlzLmZyYW1lU2FtcGxlUG9zID0gMDsKICAgICAgICAgICAgdGhpcy5zdHJlYW1GcmFtZVBvcyA9IDA7CiAgICAgICAgICAgIHRoaXMud2FzU2lnbmFsRGV0ZWN0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5pbnB1dFNhbXBsZVJhdGUgPSBpbnB1dFNhbXBsZVJhdGU7CiAgICAgICAgICAgIHRoaXMuaW50ZXJuYWxTYW1wbGVSYXRlID0gb3V0cHV0U2FtcGxlUmF0ZTsKICAgICAgICAgICAgdGhpcy5mcmFtZU1pbGxpcyA9IGZyYW1lTWlsbGlzOwogICAgICAgICAgICB0aGlzLmhpc3RvcnlGcmFtZXMgPSBoaXN0b3J5RnJhbWVzOwogICAgICAgICAgICB0aGlzLmZyYW1lU2FtcGxlcyA9IH5+KHRoaXMuaW50ZXJuYWxTYW1wbGVSYXRlICogdGhpcy5mcmFtZU1pbGxpcyAvIDEwMDApOwogICAgICAgICAgICB0aGlzLnNhbXBsZVJpbmdCdWZmZXIgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuZnJhbWVTYW1wbGVzICogdGhpcy5oaXN0b3J5RnJhbWVzKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUHJvY2VzcyBzcGVlY2ggYXVkaW8gc2FtcGxlcyBmcm9tIGEgbWljcm9waG9uZSBvciBvdGhlciBhdWRpbyBzb3VyY2UuCiAgICAgICAgICoKICAgICAgICAgKiBZb3UgY2FuIGNvbnRyb2wgd2hlbiB0byBzdGFydCBhbmQgc3RvcCBwcm9jZXNzIHNwZWVjaCBlaXRoZXIgbWFudWFsbHkgd2l0aCA8c2VlIGNyZWY9IlN0YXJ0Q29udGV4dCIvPiBhbmQgPHNlZSBjcmVmPSJTdG9wQ29udGV4dCIvPiBvcgogICAgICAgICAqIGF1dG9tYXRpY2FsbHkgYnkgcHJvdmlkaW5nIGEgdm9pY2UgYWN0aXZpdHkgZGV0ZWN0aW9uIChWQUQpIGZpZWxkIHRvIDxzZWUgY3JlZj0iU3BlZWNobHlDbGllbnQiLz4uCiAgICAgICAgICoKICAgICAgICAgKiBUaGUgYXVkaW8gaXMgaGFuZGxlZCBhcyBmb2xsb3dzOgogICAgICAgICAqIC0gRG93bnNhbXBsZSB0byAxNmtIeiBpZiBuZWVkZWQKICAgICAgICAgKiAtIEFkZCB0byBoaXN0b3J5IHJpbmdidWZmZXIKICAgICAgICAgKiAtIENhbGN1bGF0ZSBlbmVyZ3kgKFZBRCkKICAgICAgICAgKiAtIEF1dG9tYXRpYyBTdGFydC9TdG9wQ29udGV4dCAoVkFEKQogICAgICAgICAqIC0gU2VuZCB1dHRlcmFuY2UgYXVkaW8gdG8gU3BlZWNobHkgU0xVIGRlY29kZXIKICAgICAgICAgKgogICAgICAgICAqIEBwYXJhbSBmbG9hdHMgLSBBcnJheSBvZiBmbG9hdCBjb250YWluaW5nIHNhbXBsZXMgdG8gZmVlZCB0byB0aGUgYXVkaW8gcGlwZWxpbmUuIEVhY2ggc2FtcGxlIG5lZWRzIHRvIGJlIGluIHJhbmdlIC0xZi4uMWYuCiAgICAgICAgICogQHBhcmFtIHN0YXJ0IC0gU3RhcnQgaW5kZXggb2YgYXVkaW8gdG8gcHJvY2VzcyBpbiBzYW1wbGVzIChkZWZhdWx0OiBgMGApLgogICAgICAgICAqIEBwYXJhbSBsZW5ndGggLSBMZW5ndGggb2YgYXVkaW8gdG8gcHJvY2VzcyBpbiBzYW1wbGVzIG9yIGAtMWAgdG8gcHJvY2VzcyB0aGUgd2hvbGUgYXJyYXkgKGRlZmF1bHQ6IGAtMWApLgogICAgICAgICAqIEBwYXJhbSBlb3NfYXRfZW5kIC0gU3RvcFN0cmVhbSBpbnRlcm5hbGx5IHVzZXMgdGhpcyB0byBmb3JjZSBwcm9jZXNzaW5nIG9mIGxhc3Qgc3ViZnJhbWUgYXQgZW5kIG9mIGF1ZGlvIHN0cmVhbSAoZGVmYXVsdDogYGZhbHNlYCkuCiAgICAgICAgICogQHJldHVybnMKICAgICAgICAgKi8KICAgICAgICBwcm9jZXNzQXVkaW8oZmxvYXRzLCBzdGFydCA9IDAsIGxlbmd0aCA9IC0xLCBlb3NfYXRfZW5kID0gZmFsc2UpIHsKICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDApCiAgICAgICAgICAgICAgICBsZW5ndGggPSBmbG9hdHMubGVuZ3RoOwogICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7CiAgICAgICAgICAgICAgICBpZiAoZW9zX2F0X2VuZCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0VvcygpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGxldCBpID0gc3RhcnQ7CiAgICAgICAgICAgIGNvbnN0IGVuZEluZGV4ID0gc3RhcnQgKyBsZW5ndGg7CiAgICAgICAgICAgIHdoaWxlIChpIDwgZW5kSW5kZXgpIHsKICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lQmFzZSA9IHRoaXMuY3VycmVudEZyYW1lTnVtYmVyICogdGhpcy5mcmFtZVNhbXBsZXM7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnB1dFNhbXBsZVJhdGUgPT09IHRoaXMuaW50ZXJuYWxTYW1wbGVSYXRlKSB7CiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBpbnB1dCBzYW1wbGVzIHRvIGZpbGwgY3VycmVudCByaW5nYnVmZmVyIGZyYW1lCiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlc1RvRmlsbEZyYW1lID0gTWF0aC5taW4oZW5kSW5kZXggLSBpLCB0aGlzLmZyYW1lU2FtcGxlcyAtIHRoaXMuZnJhbWVTYW1wbGVQb3MpOwogICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lRW5kSW5kZXggPSB0aGlzLmZyYW1lU2FtcGxlUG9zICsgc2FtcGxlc1RvRmlsbEZyYW1lOwogICAgICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLmZyYW1lU2FtcGxlUG9zIDwgZnJhbWVFbmRJbmRleCkgewogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZVJpbmdCdWZmZXJbZnJhbWVCYXNlICsgdGhpcy5mcmFtZVNhbXBsZVBvcysrXSA9IGZsb2F0c1tpKytdOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGVsc2UgewogICAgICAgICAgICAgICAgICAgIC8vIERvd25zYW1wbGUgaW5wdXQgc2FtcGxlcyB0byBmaWxsIGN1cnJlbnQgcmluZ2J1ZmZlciBmcmFtZQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhdGlvID0gMS4wICogdGhpcy5pbnB1dFNhbXBsZVJhdGUgLyB0aGlzLmludGVybmFsU2FtcGxlUmF0ZTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFNhbXBsZXNUb0ZpbGxGcmFtZSA9IE1hdGgubWluKGVuZEluZGV4IC0gaSwgTWF0aC5yb3VuZChyYXRpbyAqICh0aGlzLmZyYW1lU2FtcGxlcyAtIHRoaXMuZnJhbWVTYW1wbGVQb3MpKSk7CiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FtcGxlc1RvRmlsbEZyYW1lID0gTWF0aC5taW4oTWF0aC5yb3VuZCgoZW5kSW5kZXggLSBpKSAvIHJhdGlvKSwgdGhpcy5mcmFtZVNhbXBsZXMgLSB0aGlzLmZyYW1lU2FtcGxlUG9zKTsKICAgICAgICAgICAgICAgICAgICBpZiAoc2FtcGxlc1RvRmlsbEZyYW1lID4gMCkgewogICAgICAgICAgICAgICAgICAgICAgICBBdWRpb1Rvb2xzLmRvd25zYW1wbGUoZmxvYXRzLCB0aGlzLnNhbXBsZVJpbmdCdWZmZXIsIGksIGlucHV0U2FtcGxlc1RvRmlsbEZyYW1lLCBmcmFtZUJhc2UgKyB0aGlzLmZyYW1lU2FtcGxlUG9zLCBzYW1wbGVzVG9GaWxsRnJhbWUpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpICs9IGlucHV0U2FtcGxlc1RvRmlsbEZyYW1lOwogICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVTYW1wbGVQb3MgKz0gc2FtcGxlc1RvRmlsbEZyYW1lOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY29uc3QgZW9zID0gaSA9PT0gZW5kSW5kZXggJiYgZW9zX2F0X2VuZDsKICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZnJhbWUKICAgICAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lU2FtcGxlUG9zID09PSB0aGlzLmZyYW1lU2FtcGxlcyB8fCBlb3MpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJGcmFtZVNhbXBsZXMgPSBlb3MgPyB0aGlzLmZyYW1lU2FtcGxlUG9zIDogdGhpcy5mcmFtZVNhbXBsZXM7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRnJhbWUodGhpcy5zYW1wbGVSaW5nQnVmZmVyLCBmcmFtZUJhc2UsIHN1YkZyYW1lU2FtcGxlcywgZW9zKTsKICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NlbmRpbmcpIHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2FtcGxlc1NlbnQgPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0IG9mIHRoZSB1dHRlcmFuY2UgLSBzZW5kIGhpc3RvcnkgZnJhbWVzCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZW5kSGlzdG9yeSA9IE1hdGgubWluKHRoaXMuc3RyZWFtRnJhbWVQb3MsIHRoaXMuaGlzdG9yeUZyYW1lcyAtIDEpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGhpc3RvcnlGcmFtZUluZGV4ID0gKHRoaXMuY3VycmVudEZyYW1lTnVtYmVyICsgdGhpcy5oaXN0b3J5RnJhbWVzIC0gc2VuZEhpc3RvcnkpICUgdGhpcy5oaXN0b3J5RnJhbWVzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGhpc3RvcnlGcmFtZUluZGV4ICE9PSB0aGlzLmN1cnJlbnRGcmFtZU51bWJlcikgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TZW5kQXVkaW8odGhpcy5zYW1wbGVSaW5nQnVmZmVyLCBoaXN0b3J5RnJhbWVJbmRleCAqIHRoaXMuZnJhbWVTYW1wbGVzLCB0aGlzLmZyYW1lU2FtcGxlcyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zYW1wbGVzU2VudCArPSB0aGlzLmZyYW1lU2FtcGxlczsKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaXN0b3J5RnJhbWVJbmRleCA9IChoaXN0b3J5RnJhbWVJbmRleCArIDEpICUgdGhpcy5oaXN0b3J5RnJhbWVzOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25TZW5kQXVkaW8odGhpcy5zYW1wbGVSaW5nQnVmZmVyLCBmcmFtZUJhc2UsIHN1YkZyYW1lU2FtcGxlcyk7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2FtcGxlc1NlbnQgKz0gc3ViRnJhbWVTYW1wbGVzOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoZW9zKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtU2FtcGxlUG9zICs9IHN1YkZyYW1lU2FtcGxlczsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRW9zKCk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuZnJhbWVTYW1wbGVQb3MgPT09IHRoaXMuZnJhbWVTYW1wbGVzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZnJhbWVTYW1wbGVQb3MgPSAwOwogICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbUZyYW1lUG9zICs9IDE7CiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RyZWFtU2FtcGxlUG9zICs9IHN1YkZyYW1lU2FtcGxlczsKICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWVOdW1iZXIgPSAodGhpcy5jdXJyZW50RnJhbWVOdW1iZXIgKyAxKSAlIHRoaXMuaGlzdG9yeUZyYW1lczsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAodGhpcy52YWQpIHsKICAgICAgICAgICAgICAgICAgICB0aGlzLndhc1NpZ25hbERldGVjdGVkID0gdGhpcy52YWQuaXNTaWduYWxEZXRlY3RlZDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXRTZW5kQXVkaW8oYWN0aXZlKSB7CiAgICAgICAgICAgIHRoaXMuaXNTZW5kaW5nID0gYWN0aXZlOwogICAgICAgICAgICBpZiAoYWN0aXZlKSB7CiAgICAgICAgICAgICAgICB0aGlzLnNhbXBsZXNTZW50ID0gMDsKICAgICAgICAgICAgICAgIHRoaXMudXR0ZXJhbmNlU2VyaWFsKys7CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgcmVzZXQoaW5wdXRTYW1wbGVSYXRlKSB7CiAgICAgICAgICAgIHZhciBfYTsKICAgICAgICAgICAgdGhpcy5pc1NlbmRpbmcgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5zdHJlYW1GcmFtZVBvcyA9IDA7CiAgICAgICAgICAgIHRoaXMuc3RyZWFtU2FtcGxlUG9zID0gMDsKICAgICAgICAgICAgdGhpcy5mcmFtZVNhbXBsZVBvcyA9IDA7CiAgICAgICAgICAgIHRoaXMuY3VycmVudEZyYW1lTnVtYmVyID0gMDsKICAgICAgICAgICAgdGhpcy51dHRlcmFuY2VTZXJpYWwgPSAtMTsKICAgICAgICAgICAgaWYgKGlucHV0U2FtcGxlUmF0ZSkKICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRTYW1wbGVSYXRlID0gaW5wdXRTYW1wbGVSYXRlOwogICAgICAgICAgICB0aGlzLndhc1NpZ25hbERldGVjdGVkID0gZmFsc2U7CiAgICAgICAgICAgIChfYSA9IHRoaXMudmFkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXRWQUQoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogQHJldHVybnMgY3VycmVudCBwb3NpdGlvbiBpbiBzdHJlYW0gaW4gbWlsbGlzZWNvbmRzCiAgICAgICAgICovCiAgICAgICAgZ2V0U3RyZWFtUG9zaXRpb24oKSB7CiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHRoaXMuc3RyZWFtU2FtcGxlUG9zIC8gdGhpcy5pbnRlcm5hbFNhbXBsZVJhdGUgKiAxMDAwKTsKICAgICAgICB9CiAgICAgICAgZW9zKCkgewogICAgICAgICAgICB0aGlzLnByb2Nlc3NBdWRpbyh0aGlzLnNhbXBsZVJpbmdCdWZmZXIsIDAsIHRoaXMuZnJhbWVTYW1wbGVQb3MsIHRydWUpOwogICAgICAgIH0KICAgICAgICBwcm9jZXNzRnJhbWUoZmxvYXRzLCBzdGFydCA9IDAsIGxlbmd0aCA9IC0xLCBlb3MgPSBmYWxzZSkgewogICAgICAgICAgICB2YXIgX2E7CiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLnZhZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhZE9wdGlvbnMuZW5hYmxlZCkgewogICAgICAgICAgICAgICAgdGhpcy52YWQucHJvY2Vzc0ZyYW1lKGZsb2F0cywgc3RhcnQsIGxlbmd0aCwgZW9zKTsKICAgICAgICAgICAgICAgIGlmICh0aGlzLnZhZC5pc1NpZ25hbERldGVjdGVkICE9PSB0aGlzLndhc1NpZ25hbERldGVjdGVkKSB7CiAgICAgICAgICAgICAgICAgICAgdGhpcy5vblZhZFN0YXRlQ2hhbmdlKHRoaXMudmFkLmlzU2lnbmFsRGV0ZWN0ZWQpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHByb2Nlc3NFb3MoKSB7CiAgICAgICAgICAgIHZhciBfYTsKICAgICAgICAgICAgaWYgKHRoaXMuaXNTZW5kaW5nICYmICgoX2EgPSB0aGlzLnZhZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhZE9wdGlvbnMuZW5hYmxlZCkpIHsKICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBWQUQgc3RhdGUgY2hhbmdlIG9uIGVuZC1vZi1zdHJlYW0KICAgICAgICAgICAgICAgIHRoaXMudmFkLnJlc2V0VkFEKCk7CiAgICAgICAgICAgICAgICB0aGlzLm9uVmFkU3RhdGVDaGFuZ2UoZmFsc2UpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgfQoKICAgIC8qKgogICAgICogQWRhcHRpdmUgZW5lcmd5IHRocmVzaG9sZCB2b2ljZSBhY3Rpdml0eSBkZXRlY3Rpb24gKFZBRCkgaW1wbGVtZW50YXRpb24uCiAgICAgKiBJdCBjYW4gYmUgdXNlZCB0byBlbmFibGUgaGFuZHMtZnJlZSBvcGVyYXRpb24gb2YgdGhlIFNMVSBkZWNvZGVyLgogICAgICoKICAgICAqIFdoZW4gZW5vdWdoIGZyYW1lcyB3aXRoIGEgc2lnbmFsIHN0cm9uZ2VyIHRoYW4gU2lnbmFsVG9Ob2lzZURiIGhhdmUgYmVlbiBkZXRlY3RlZCwgSXNTaWduYWxEZXRlY3RlZCBnb2VzIHRydWUuIFdoZW4gZW5vdWdoIHNpbGVudCBmcmFtZXMgaGF2ZSBiZWVuIGRldGVjdGVkLCBJc1NpZ25hbERldGVjdGVkIGdvZXMgZmFsc2UgYWZ0ZXIgdGhlIHN1c3RhaW4gdGltZS4KICAgICAqIFVzZSBpdHMgcHVibGljIGZpZWxkcyB0byBjb25maWd1cmUgdGhlIHN0YXRpYyBub2lzZSBnYXRlIGxldmVsLCBzaWduYWwtdG8tbm9pc2UgbGV2ZWwsIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIHRyZXNob2xkIChyYXRpbyBvZiBzaWduYWwgdG8gc2lsZW50IGZyYW1lcykgYW5kIHRoZSBzaWduYWwgc3VzdGFpbiB0aW1lLgogICAgICogVGhlIGJhY2tncm91bmQgbm9pc2UgbGV2ZWwgZ3JhZHVhbGx5IGFkYXB0cyB3aGVuIG5vIHNpZ25hbCBpcyBkZXRlY3RlZC4KICAgICAqCiAgICAgKiBJc1NpZ25hbERldGVjdGVkIGNhbiBiZSB1c2VkIHRvIGRyaXZlIFNwZWVjaGx5Q2xpZW50J3MgU3RhcnRDb250ZXh0IGFuZCBTdG9wQ29udGV4dCBhdXRvbWF0aWNhbGx5IGJ5IHNldHRpbmcgQ29udHJvbExpc3RlbmluZyB0cnVlLgogICAgICogQGludGVybmFsCiAgICAgKi8KICAgIGNsYXNzIEVuZXJneVRyZXNob2xkVkFEIHsKICAgICAgICBjb25zdHJ1Y3RvcihmcmFtZU1pbGxpcywgdmFkT3B0aW9ucykgewogICAgICAgICAgICB0aGlzLmlzU2lnbmFsRGV0ZWN0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5zaWduYWxEYiA9IC05MC4wOwogICAgICAgICAgICB0aGlzLm5vaXNlTGV2ZWxEYiA9IC05MC4wOwogICAgICAgICAgICB0aGlzLmZyYW1lTWlsbGlzID0gMzA7CiAgICAgICAgICAgIHRoaXMuZW5lcmd5ID0gMC4wOwogICAgICAgICAgICB0aGlzLmJhc2VsaW5lRW5lcmd5ID0gLTEuMDsKICAgICAgICAgICAgdGhpcy5sb3VkRnJhbWVCaXRzID0gMDsKICAgICAgICAgICAgdGhpcy52YWRTdXN0YWluTWlsbGlzTGVmdCA9IDA7CiAgICAgICAgICAgIHRoaXMuZnJhbWVNaWxsaXMgPSBmcmFtZU1pbGxpczsKICAgICAgICAgICAgdGhpcy52YWRPcHRpb25zID0gdmFkT3B0aW9uczsKICAgICAgICB9CiAgICAgICAgYWRqdXN0VmFkT3B0aW9ucyh2YWRPcHRpb25zKSB7CiAgICAgICAgICAgIHRoaXMudmFkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52YWRPcHRpb25zKSwgdmFkT3B0aW9ucyk7CiAgICAgICAgfQogICAgICAgIHJlc2V0VkFEKCkgewogICAgICAgICAgICB0aGlzLmlzU2lnbmFsRGV0ZWN0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5sb3VkRnJhbWVCaXRzID0gMDsKICAgICAgICAgICAgdGhpcy5lbmVyZ3kgPSAwOwogICAgICAgICAgICB0aGlzLmJhc2VsaW5lRW5lcmd5ID0gLTE7CiAgICAgICAgfQogICAgICAgIHByb2Nlc3NGcmFtZShmbG9hdHMsIHN0YXJ0ID0gMCwgbGVuZ3RoID0gLTEsIGVvcyA9IGZhbHNlKSB7CiAgICAgICAgICAgIGlmICghdGhpcy52YWRPcHRpb25zLmVuYWJsZWQpIHsKICAgICAgICAgICAgICAgIHRoaXMucmVzZXRWQUQoKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoZW9zKQogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB0aGlzLmVuZXJneSA9IEF1ZGlvVG9vbHMuZ2V0RW5lcmd5KGZsb2F0cywgc3RhcnQsIGxlbmd0aCk7CiAgICAgICAgICAgIGlmICh0aGlzLmJhc2VsaW5lRW5lcmd5IDwgMCkgewogICAgICAgICAgICAgICAgdGhpcy5iYXNlbGluZUVuZXJneSA9IHRoaXMuZW5lcmd5OwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IGlzTG91ZEZyYW1lID0gdGhpcy5lbmVyZ3kgPiBNYXRoLm1heChBdWRpb1Rvb2xzLmRiVG9FbmVyZ3kodGhpcy52YWRPcHRpb25zLm5vaXNlR2F0ZURiKSwgdGhpcy5iYXNlbGluZUVuZXJneSAqIEF1ZGlvVG9vbHMuZGJUb0VuZXJneSh0aGlzLnZhZE9wdGlvbnMuc2lnbmFsVG9Ob2lzZURiKSk7CiAgICAgICAgICAgIHRoaXMucHVzaEZyYW1lSGlzdG9yeShpc0xvdWRGcmFtZSk7CiAgICAgICAgICAgIHRoaXMuaXNTaWduYWxEZXRlY3RlZCA9IHRoaXMuZGV0ZXJtaW5lTmV3U2lnbmFsU3RhdGUodGhpcy5pc1NpZ25hbERldGVjdGVkKTsKICAgICAgICAgICAgdGhpcy5hZGFwdEJhY2tncm91bmROb2lzZSgpOwogICAgICAgICAgICB0aGlzLnNpZ25hbERiID0gQXVkaW9Ub29scy5lbmVyZ3lUb0RiKHRoaXMuZW5lcmd5IC8gdGhpcy5iYXNlbGluZUVuZXJneSk7CiAgICAgICAgICAgIHRoaXMubm9pc2VMZXZlbERiID0gQXVkaW9Ub29scy5lbmVyZ3lUb0RiKHRoaXMuYmFzZWxpbmVFbmVyZ3kpOwogICAgICAgIH0KICAgICAgICBkZXRlcm1pbmVOZXdTaWduYWxTdGF0ZShjdXJyZW50U3RhdGUpIHsKICAgICAgICAgICAgdGhpcy52YWRTdXN0YWluTWlsbGlzTGVmdCA9IE1hdGgubWF4KHRoaXMudmFkU3VzdGFpbk1pbGxpc0xlZnQgLSB0aGlzLmZyYW1lTWlsbGlzLCAwKTsKICAgICAgICAgICAgY29uc3QgbG91ZEZyYW1lcyA9IHRoaXMuY291bnRMb3VkRnJhbWVzKHRoaXMudmFkT3B0aW9ucy5zaWduYWxTZWFyY2hGcmFtZXMpOwogICAgICAgICAgICBjb25zdCBhY3RpdmF0aW9uRnJhbWVzID0gTWF0aC5yb3VuZCh0aGlzLnZhZE9wdGlvbnMuc2lnbmFsQWN0aXZhdGlvbiAqIHRoaXMudmFkT3B0aW9ucy5zaWduYWxTZWFyY2hGcmFtZXMpOwogICAgICAgICAgICBjb25zdCByZWxlYXNlRnJhbWVzID0gTWF0aC5yb3VuZCh0aGlzLnZhZE9wdGlvbnMuc2lnbmFsUmVsZWFzZSAqIHRoaXMudmFkT3B0aW9ucy5zaWduYWxTZWFyY2hGcmFtZXMpOwogICAgICAgICAgICBpZiAobG91ZEZyYW1lcyA+PSBhY3RpdmF0aW9uRnJhbWVzKSB7CiAgICAgICAgICAgICAgICAvLyBSZW5ldyBzdXN0YWluIHRpbWUKICAgICAgICAgICAgICAgIHRoaXMudmFkU3VzdGFpbk1pbGxpc0xlZnQgPSB0aGlzLnZhZE9wdGlvbnMuc2lnbmFsU3VzdGFpbk1pbGxpczsKICAgICAgICAgICAgICAgIHJldHVybiB0cnVlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmIChsb3VkRnJhbWVzIDw9IHJlbGVhc2VGcmFtZXMgJiYgdGhpcy52YWRTdXN0YWluTWlsbGlzTGVmdCA9PT0gMCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7CiAgICAgICAgfQogICAgICAgIGFkYXB0QmFja2dyb3VuZE5vaXNlKCkgewogICAgICAgICAgICAvLyBHcmFkdWFsbHkgbGVhcm4gYmFja2dyb3VuZCBub2lzZSBsZXZlbAogICAgICAgICAgICBpZiAoIXRoaXMuaXNTaWduYWxEZXRlY3RlZCkgewogICAgICAgICAgICAgICAgaWYgKHRoaXMudmFkT3B0aW9ucy5ub2lzZUxlYXJuSGFsZnRpbWVNaWxsaXMgPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgdmFyIGRlY2F5ID0gTWF0aC5wb3coMi4wLCAtdGhpcy5mcmFtZU1pbGxpcyAvIHRoaXMudmFkT3B0aW9ucy5ub2lzZUxlYXJuSGFsZnRpbWVNaWxsaXMpOwogICAgICAgICAgICAgICAgICAgIHRoaXMuYmFzZWxpbmVFbmVyZ3kgPSAodGhpcy5iYXNlbGluZUVuZXJneSAqIGRlY2F5KSArICh0aGlzLmVuZXJneSAqICgxIC0gZGVjYXkpKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBwdXNoRnJhbWVIaXN0b3J5KGlzTG91ZCkgewogICAgICAgICAgICB0aGlzLmxvdWRGcmFtZUJpdHMgPSAoaXNMb3VkID8gMSA6IDApIHwgKHRoaXMubG91ZEZyYW1lQml0cyA8PCAxKTsKICAgICAgICB9CiAgICAgICAgY291bnRMb3VkRnJhbWVzKG51bUhpc3RvcnlGcmFtZXMpIHsKICAgICAgICAgICAgbGV0IG51bUFjdGl2ZUZyYW1lcyA9IDA7CiAgICAgICAgICAgIGxldCB0ID0gdGhpcy5sb3VkRnJhbWVCaXRzOwogICAgICAgICAgICB3aGlsZSAobnVtSGlzdG9yeUZyYW1lcyA+IDApIHsKICAgICAgICAgICAgICAgIGlmICgodCAmIDEpID09PSAxKQogICAgICAgICAgICAgICAgICAgIG51bUFjdGl2ZUZyYW1lcysrOwogICAgICAgICAgICAgICAgdCA9IHQgPj4gMTsKICAgICAgICAgICAgICAgIG51bUhpc3RvcnlGcmFtZXMtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbnVtQWN0aXZlRnJhbWVzOwogICAgICAgIH0KICAgIH0KCiAgICAvKioKICAgICAqIEtub3duIFdlYlNvY2tldCByZXNwb25zZSB0eXBlcy4KICAgICAqIEBpbnRlcm5hbAogICAgICovCiAgICB2YXIgV2Vic29ja2V0UmVzcG9uc2VUeXBlOwogICAgKGZ1bmN0aW9uIChXZWJzb2NrZXRSZXNwb25zZVR5cGUpIHsKICAgICAgICBXZWJzb2NrZXRSZXNwb25zZVR5cGVbIlN0YXJ0ZWQiXSA9ICJzdGFydGVkIjsKICAgICAgICBXZWJzb2NrZXRSZXNwb25zZVR5cGVbIlN0b3BwZWQiXSA9ICJzdG9wcGVkIjsKICAgICAgICBXZWJzb2NrZXRSZXNwb25zZVR5cGVbIlNlZ21lbnRFbmQiXSA9ICJzZWdtZW50X2VuZCI7CiAgICAgICAgV2Vic29ja2V0UmVzcG9uc2VUeXBlWyJUcmFuc2NyaXB0Il0gPSAidHJhbnNjcmlwdCI7CiAgICAgICAgV2Vic29ja2V0UmVzcG9uc2VUeXBlWyJFbnRpdHkiXSA9ICJlbnRpdHkiOwogICAgICAgIFdlYnNvY2tldFJlc3BvbnNlVHlwZVsiSW50ZW50Il0gPSAiaW50ZW50IjsKICAgICAgICBXZWJzb2NrZXRSZXNwb25zZVR5cGVbIlRlbnRhdGl2ZVRyYW5zY3JpcHQiXSA9ICJ0ZW50YXRpdmVfdHJhbnNjcmlwdCI7CiAgICAgICAgV2Vic29ja2V0UmVzcG9uc2VUeXBlWyJUZW50YXRpdmVFbnRpdGllcyJdID0gInRlbnRhdGl2ZV9lbnRpdGllcyI7CiAgICAgICAgV2Vic29ja2V0UmVzcG9uc2VUeXBlWyJUZW50YXRpdmVJbnRlbnQiXSA9ICJ0ZW50YXRpdmVfaW50ZW50IjsKICAgIH0pKFdlYnNvY2tldFJlc3BvbnNlVHlwZSB8fCAoV2Vic29ja2V0UmVzcG9uc2VUeXBlID0ge30pKTsKICAgIC8qKgogICAgICogTWVzc2FnZXMgZnJvbSB3b3JrZXIgdG8gY29udHJvbGxlcgogICAgICogQGludGVybmFsCiAgICAgKi8KICAgIHZhciBXb3JrZXJTaWduYWw7CiAgICAoZnVuY3Rpb24gKFdvcmtlclNpZ25hbCkgewogICAgICAgIFdvcmtlclNpZ25hbFsiT3BlbmVkIl0gPSAiV0VCU09DS0VUX09QRU4iOwogICAgICAgIFdvcmtlclNpZ25hbFsiQ2xvc2VkIl0gPSAiV0VCU09DS0VUX0NMT1NFRCI7CiAgICAgICAgV29ya2VyU2lnbmFsWyJBdWRpb1Byb2Nlc3NvclJlYWR5Il0gPSAiU09VUkNFX1NBTVBMRV9SQVRFX1NFVF9TVUNDRVNTIjsKICAgICAgICBXb3JrZXJTaWduYWxbIlZhZFNpZ25hbEhpZ2giXSA9ICJWYWRTaWduYWxIaWdoIjsKICAgICAgICBXb3JrZXJTaWduYWxbIlZhZFNpZ25hbExvdyJdID0gIlZhZFNpZ25hbExvdyI7CiAgICAgICAgV29ya2VyU2lnbmFsWyJSZXF1ZXN0Q29udGV4dFN0YXJ0Il0gPSAiUmVxdWVzdENvbnRleHRTdGFydCI7CiAgICB9KShXb3JrZXJTaWduYWwgfHwgKFdvcmtlclNpZ25hbCA9IHt9KSk7CiAgICAvKioKICAgICAqIE1lc3NhZ2VzIGZyb20gY29udHJvbGxlciB0byB3b3JrZXIKICAgICAqIEBpbnRlcm5hbAogICAgICovCiAgICB2YXIgQ29udHJvbGxlclNpZ25hbDsKICAgIChmdW5jdGlvbiAoQ29udHJvbGxlclNpZ25hbCkgewogICAgICAgIENvbnRyb2xsZXJTaWduYWxbImNvbm5lY3QiXSA9ICJjb25uZWN0IjsKICAgICAgICBDb250cm9sbGVyU2lnbmFsWyJpbml0QXVkaW9Qcm9jZXNzb3IiXSA9ICJpbml0QXVkaW9Qcm9jZXNzb3IiOwogICAgICAgIENvbnRyb2xsZXJTaWduYWxbImFkanVzdEF1ZGlvUHJvY2Vzc29yIl0gPSAiYWRqdXN0QXVkaW9Qcm9jZXNzb3IiOwogICAgICAgIENvbnRyb2xsZXJTaWduYWxbIlNFVF9TSEFSRURfQVJSQVlfQlVGRkVSUyJdID0gIlNFVF9TSEFSRURfQVJSQVlfQlVGRkVSUyI7CiAgICAgICAgQ29udHJvbGxlclNpZ25hbFsiQ0xPU0UiXSA9ICJDTE9TRSI7CiAgICAgICAgQ29udHJvbGxlclNpZ25hbFsiU1RBUlRfQ09OVEVYVCJdID0gIlNUQVJUX0NPTlRFWFQiOwogICAgICAgIENvbnRyb2xsZXJTaWduYWxbIlNXSVRDSF9DT05URVhUIl0gPSAiU1dJVENIX0NPTlRFWFQiOwogICAgICAgIENvbnRyb2xsZXJTaWduYWxbIlNUT1BfQ09OVEVYVCJdID0gIlNUT1BfQ09OVEVYVCI7CiAgICAgICAgQ29udHJvbGxlclNpZ25hbFsiQVVESU8iXSA9ICJBVURJTyI7CiAgICAgICAgQ29udHJvbGxlclNpZ25hbFsic3RhcnRTdHJlYW0iXSA9ICJzdGFydFN0cmVhbSI7CiAgICAgICAgQ29udHJvbGxlclNpZ25hbFsic3RvcFN0cmVhbSJdID0gInN0b3BTdHJlYW0iOwogICAgICAgIENvbnRyb2xsZXJTaWduYWxbInNldENvbnRleHRPcHRpb25zIl0gPSAic2V0Q29udGV4dE9wdGlvbnMiOwogICAgfSkoQ29udHJvbGxlclNpZ25hbCB8fCAoQ29udHJvbGxlclNpZ25hbCA9IHt9KSk7CgogICAgY29uc3QgQ09OVFJPTCA9IHsKICAgICAgICBXUklURV9JTkRFWDogMCwKICAgICAgICBGUkFNRVNfQVZBSUxBQkxFOiAxLAogICAgICAgIExPQ0s6IDIsCiAgICB9OwogICAgLyoqCiAgICAgKiBXZWIgd29ya2VyIHRvIGhhbmRsZSBzdHJlYW1pbmcgYXVkaW8gdG8gY2xvdWQgYW5kIHJlY2VpdmluZyBzcGVlY2ggcHJvY2Vzc2luZyByZXN1bHRzLgogICAgICogQWxzbyBoYW5kbGVzIGF1ZGlvIHByb2Nlc3NpbmcgbGlrZSBtYWludGFpbmluZyBoaXN0b3J5IHJpbmdidWZmZXIgYW5kIHJ1bm5pbmcgdGhlIFZBRAogICAgICogQGludGVybmFsCiAgICAgKi8KICAgIGNsYXNzIFdlYnNvY2tldENsaWVudCB7CiAgICAgICAgY29uc3RydWN0b3IoY3R4KSB7CiAgICAgICAgICAgIHRoaXMudGFyZ2V0U2FtcGxlUmF0ZSA9IDE2MDAwOwogICAgICAgICAgICB0aGlzLmlzQ29udGV4dFN0YXJ0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgdGhpcy5hdWRpb0NvbnRleHRTdGFydFRpbWVzID0gW107CiAgICAgICAgICAgIHRoaXMuaW1tZWRpYXRlTW9kZSA9IGZhbHNlOwogICAgICAgICAgICB0aGlzLmZyYW1lTWlsbGlzID0gMzA7CiAgICAgICAgICAgIHRoaXMub3V0cHV0QXVkaW9GcmFtZSA9IG5ldyBJbnQxNkFycmF5KHRoaXMuZnJhbWVNaWxsaXMgKiB0aGlzLnRhcmdldFNhbXBsZVJhdGUgLyAxMDAwKTsKICAgICAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlOwogICAgICAgICAgICAvLyBXZWJTb2NrZXQncyBjbG9zZSBoYW5kbGVyLCBjYWxsZWQgZS5nLiB3aGVuCiAgICAgICAgICAgIC8vIC0gbm9ybWFsIGNsb3NlIChjb2RlIDEwMDApCiAgICAgICAgICAgIC8vIC0gbmV0d29yayB1bnJlYWNoYWJsZSBvciB1bmFibGUgdG8gKHJlKWNvbm5lY3QgKGNvZGUgMTAwNikKICAgICAgICAgICAgLy8gTGlzdCBvZiBDbG9zZUV2ZW50LmNvZGUgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2xvc2VFdmVudC9jb2RlCiAgICAgICAgICAgIHRoaXMub25XZWJzb2NrZXRDbG9zZSA9IChldmVudCkgPT4gewogICAgICAgICAgICAgICAgdmFyIF9hOwogICAgICAgICAgICAgICAgaWYgKCF0aGlzLndlYnNvY2tldCkgewogICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdXZWJTb2NrZXQgaXMgdW5kZWZpbmVkJyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAvLyBSZXNldCBhdWRpb3Byb2Nlc3NvciBzbyBpdCB3b24ndCB0cnkgdG8gc2VuZCBhdWRpbyB0aGUgZmlyc3QgdGhpbmcgd2hlbiByZWNvbm5lY3QgaGFwcGVucy4gVGhpcyB3aWxsIGxlYWQgdG8gYSByZWNvbm5lY3QgbG9vcC4KICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuYXVkaW9Qcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldCgpOwogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1dlYlNvY2tldENsaWVudF0nLCAnb25XZWJzb2NrZXRDbG9zZScpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIHRoaXMub25XZWJzb2NrZXRPcGVuKTsKICAgICAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uV2Vic29ja2V0TWVzc2FnZSk7CiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIHRoaXMub25XZWJzb2NrZXRFcnJvcik7CiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbG9zZScsIHRoaXMub25XZWJzb2NrZXRDbG9zZSk7CiAgICAgICAgICAgICAgICB0aGlzLndlYnNvY2tldCA9IHVuZGVmaW5lZDsKICAgICAgICAgICAgICAgIHRoaXMud29ya2VyQ3R4LnBvc3RNZXNzYWdlKHsKICAgICAgICAgICAgICAgICAgICB0eXBlOiBXb3JrZXJTaWduYWwuQ2xvc2VkLAogICAgICAgICAgICAgICAgICAgIGNvZGU6IGV2ZW50LmNvZGUsCiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBldmVudC5yZWFzb24sCiAgICAgICAgICAgICAgICAgICAgd2FzQ2xlYW46IGV2ZW50Lndhc0NsZWFuLAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH07CiAgICAgICAgICAgIHRoaXMub25XZWJzb2NrZXRPcGVuID0gKF9ldmVudCkgPT4gewogICAgICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1dlYlNvY2tldENsaWVudF0nLCAnd2Vic29ja2V0IG9wZW5lZCcpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy53b3JrZXJDdHgucG9zdE1lc3NhZ2UoeyB0eXBlOiBXb3JrZXJTaWduYWwuT3BlbmVkIH0pOwogICAgICAgICAgICB9OwogICAgICAgICAgICB0aGlzLm9uV2Vic29ja2V0RXJyb3IgPSAoX2V2ZW50KSA9PiB7CiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZykgewogICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbV2ViU29ja2V0Q2xpZW50XScsICd3ZWJzb2NrZXQgZXJyb3InKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfTsKICAgICAgICAgICAgdGhpcy5vbldlYnNvY2tldE1lc3NhZ2UgPSAoZXZlbnQpID0+IHsKICAgICAgICAgICAgICAgIGxldCByZXNwb25zZTsKICAgICAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbV2ViU29ja2V0Q2xpZW50XScsICdlcnJvciBwYXJzaW5nIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlcjonLCBlKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gV2Vic29ja2V0UmVzcG9uc2VUeXBlLlN0YXJ0ZWQpIHsKICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgY2xpZW50LXNpZGUgbWV0YWRhdGEgdG8gdGhlIGJhY2tlbmQgbWVzc2FnZQogICAgICAgICAgICAgICAgICAgIGxldCBhdWRpb0NvbnRleHRTdGFydFRpbWUgPSB0aGlzLmF1ZGlvQ29udGV4dFN0YXJ0VGltZXMuc2hpZnQoKTsKICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9Db250ZXh0U3RhcnRUaW1lID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdObyB2YWxpZCB2YWx1ZSBmb3IgY29udGV4dFN0YXJ0TWlsbGlzJyk7CiAgICAgICAgICAgICAgICAgICAgICAgIGF1ZGlvQ29udGV4dFN0YXJ0VGltZSA9IDA7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29udGV4dFBhcmFtcyA9IHsKICAgICAgICAgICAgICAgICAgICAgICAgYXVkaW9TdGFydFRpbWVNaWxsaXM6IGF1ZGlvQ29udGV4dFN0YXJ0VGltZSwKICAgICAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcmFtcyA9IHN0YXJ0Q29udGV4dFBhcmFtczsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHRoaXMud29ya2VyQ3R4LnBvc3RNZXNzYWdlKHJlc3BvbnNlKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgdGhpcy53b3JrZXJDdHggPSBjdHg7CiAgICAgICAgfQogICAgICAgIGNvbm5lY3QoYXBpVXJsLCBhdXRoVG9rZW4sIHRhcmdldFNhbXBsZVJhdGUsIGRlYnVnKSB7CiAgICAgICAgICAgIHRoaXMuZGVidWcgPSBkZWJ1ZzsKICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbV2ViU29ja2V0Q2xpZW50XScsICdjb25uZWN0aW5nIHRvICcsIGFwaVVybCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy50YXJnZXRTYW1wbGVSYXRlID0gdGFyZ2V0U2FtcGxlUmF0ZTsKICAgICAgICAgICAgdGhpcy5pc0NvbnRleHRTdGFydGVkID0gZmFsc2U7CiAgICAgICAgICAgIHRoaXMud2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldChhcGlVcmwsIGF1dGhUb2tlbik7CiAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCB0aGlzLm9uV2Vic29ja2V0T3Blbik7CiAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uV2Vic29ja2V0TWVzc2FnZSk7CiAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5vbldlYnNvY2tldEVycm9yKTsKICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLm9uV2Vic29ja2V0Q2xvc2UpOwogICAgICAgIH0KICAgICAgICBpbml0QXVkaW9Qcm9jZXNzb3Ioc291cmNlU2FtcGxlUmF0ZSwgZnJhbWVNaWxsaXMsIGhpc3RvcnlGcmFtZXMsIHZhZE9wdGlvbnMpIHsKICAgICAgICAgICAgdGhpcy5hdWRpb1Byb2Nlc3NvciA9IG5ldyBBdWRpb1Byb2Nlc3Nvcihzb3VyY2VTYW1wbGVSYXRlLCB0aGlzLnRhcmdldFNhbXBsZVJhdGUsIGZyYW1lTWlsbGlzLCBoaXN0b3J5RnJhbWVzKTsKICAgICAgICAgICAgaWYgKHZhZE9wdGlvbnMpIHsKICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Qcm9jZXNzb3IudmFkID0gbmV3IEVuZXJneVRyZXNob2xkVkFEKGZyYW1lTWlsbGlzLCB2YWRPcHRpb25zKTsKICAgICAgICAgICAgICAgIHRoaXMuYXVkaW9Qcm9jZXNzb3Iub25WYWRTdGF0ZUNoYW5nZSA9IChpc1NpZ25hbERldGVjdGVkKSA9PiB7CiAgICAgICAgICAgICAgICAgICAgdmFyIF9hLCBfYjsKICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmFkT3B0aW9ucyA9IChfYiA9IChfYSA9IHRoaXMuYXVkaW9Qcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52YWRPcHRpb25zOwogICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudFZhZE9wdGlvbnMpCiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaWduYWxEZXRlY3RlZCkgewogICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaW1tZWRpYXRlTW9kZSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy53b3JrZXJDdHgucG9zdE1lc3NhZ2UoeyB0eXBlOiBXb3JrZXJTaWduYWwuVmFkU2lnbmFsSGlnaCB9KTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50VmFkT3B0aW9ucy5jb250cm9sTGlzdGVuaW5nKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0Q29udGV4dCh0aGlzLmRlZmF1bHRDb250ZXh0T3B0aW9ucyk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1NpZ25hbERldGVjdGVkKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbW1lZGlhdGVNb2RlKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndvcmtlckN0eC5wb3N0TWVzc2FnZSh7IHR5cGU6IFdvcmtlclNpZ25hbC5WYWRTaWduYWxMb3cgfSk7CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudFZhZE9wdGlvbnMuY29udHJvbExpc3RlbmluZykgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wQ29udGV4dCgpOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmF1ZGlvUHJvY2Vzc29yLm9uU2VuZEF1ZGlvID0gKGZsb2F0cywgc3RhcnRJbmRleCwgbGVuZ3RoKSA9PiB7CiAgICAgICAgICAgICAgICBBdWRpb1Rvb2xzLmNvbnZlcnRGbG9hdFRvSW50MTYoZmxvYXRzLCB0aGlzLm91dHB1dEF1ZGlvRnJhbWUsIHN0YXJ0SW5kZXgsIGxlbmd0aCk7CiAgICAgICAgICAgICAgICB0aGlzLnNlbmQodGhpcy5vdXRwdXRBdWRpb0ZyYW1lKTsKICAgICAgICAgICAgfTsKICAgICAgICAgICAgaWYgKHRoaXMud29ya2VyQ3R4ID09PSB1bmRlZmluZWQpCiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIHRoaXMud29ya2VyQ3R4LnBvc3RNZXNzYWdlKHsgdHlwZTogV29ya2VyU2lnbmFsLkF1ZGlvUHJvY2Vzc29yUmVhZHkgfSk7CiAgICAgICAgfQogICAgICAgIC8qKgogICAgICAgICAqIENvbnRyb2wgYXVkaW8gcHJvY2Vzc29yIHBhcmFtZXRlcnMKICAgICAgICAgKiBAcGFyYW0gYXAgLSBBdWRpbyBwcm9jZXNzb3IgcGFyYW1ldGVycyB0byBhZGp1c3QKICAgICAgICAgKi8KICAgICAgICBhZGp1c3RBdWRpb1Byb2Nlc3NvcihhcCkgewogICAgICAgICAgICBpZiAodGhpcy5hdWRpb1Byb2Nlc3NvciAmJiBhcC52YWQpIHsKICAgICAgICAgICAgICAgIGlmICghdGhpcy5hdWRpb1Byb2Nlc3Nvci52YWQpIHsKICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFZBRCBpbiBBdWRpb1Byb2Nlc3Nvci4gRGlkIHlvdSBkZWZpbmUgYHZhZGAgaW4gQnJvd3NlckNsaWVudCBjb25zdHJ1Y3RvciBwYXJhbWV0ZXJzPycpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgdGhpcy5hdWRpb1Byb2Nlc3Nvci52YWQuYWRqdXN0VmFkT3B0aW9ucyhhcC52YWQpOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHNldFNoYXJlZEFycmF5QnVmZmVycyhjb250cm9sU0FCLCBkYXRhU0FCKSB7CiAgICAgICAgICAgIHRoaXMuY29udHJvbFNBQiA9IG5ldyBJbnQzMkFycmF5KGNvbnRyb2xTQUIpOwogICAgICAgICAgICB0aGlzLmRhdGFTQUIgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGFTQUIpOwogICAgICAgICAgICBjb25zdCBhdWRpb0hhbmRsZUludGVydmFsID0gdGhpcy5kYXRhU0FCLmxlbmd0aCAvIDMyOyAvLyBtcwogICAgICAgICAgICBpZiAodGhpcy5kZWJ1ZykgewogICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1tXZWJTb2NrZXRDbGllbnRdJywgJ0F1ZGlvIGhhbmRsZSBpbnRlcnZhbCcsIGF1ZGlvSGFuZGxlSW50ZXJ2YWwsICdtcycpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHNldEludGVydmFsKHRoaXMucHJvY2Vzc0F1ZGlvU0FCLmJpbmQodGhpcyksIGF1ZGlvSGFuZGxlSW50ZXJ2YWwpOwogICAgICAgIH0KICAgICAgICBzdGFydFN0cmVhbShzdHJlYW1PcHRpb25zKSB7CiAgICAgICAgICAgIGlmICghdGhpcy5hdWRpb1Byb2Nlc3NvcikgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBBdWRpb1Byb2Nlc3NvcicpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMuaW1tZWRpYXRlTW9kZSA9IHN0cmVhbU9wdGlvbnMuaW1tZWRpYXRlOwogICAgICAgICAgICB0aGlzLmF1ZGlvUHJvY2Vzc29yLnJlc2V0KHN0cmVhbU9wdGlvbnMuc2FtcGxlUmF0ZSk7CiAgICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhcnRUaW1lcyA9IFtdOwogICAgICAgIH0KICAgICAgICBzdG9wU3RyZWFtKCkgewogICAgICAgICAgICBpZiAoIXRoaXMuYXVkaW9Qcm9jZXNzb3IpIHsKICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gQXVkaW9Qcm9jZXNzb3InKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvLyBTZW5kIEVPUy4gRW5zdXJlIFZBRCB3aWxsIGdvIG9mZiBhdCBlbmQgb2Ygc3RyZWFtIGFuZCBzdG9wQ29udGV4dCBpcyBjYWxsZWQgaW4gaW1tZWRpYXRlIG1vZGUKICAgICAgICAgICAgdGhpcy5hdWRpb1Byb2Nlc3Nvci5lb3MoKTsKICAgICAgICB9CiAgICAgICAgLyoqCiAgICAgICAgICogUHJvY2Vzc2VzIGFuZCBzZW5kcyBhdWRpbwogICAgICAgICAqIEBwYXJhbSBhdWRpb0NodW5rIC0gYXVkaW8gZGF0YSB0byBwcm9jZXNzCiAgICAgICAgICovCiAgICAgICAgcHJvY2Vzc0F1ZGlvKGF1ZGlvQ2h1bmspIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmF1ZGlvUHJvY2Vzc29yKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIEF1ZGlvUHJvY2Vzc29yJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5hdWRpb1Byb2Nlc3Nvci5wcm9jZXNzQXVkaW8oYXVkaW9DaHVuayk7CiAgICAgICAgfQogICAgICAgIHByb2Nlc3NBdWRpb1NBQigpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyb2xTQUIgfHwgIXRoaXMuZGF0YVNBQikgewogICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTaGFyZWRBcnJheUJ1ZmZlcnMnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBmcmFtZXNBdmFpbGFibGUgPSB0aGlzLmNvbnRyb2xTQUJbQ09OVFJPTC5GUkFNRVNfQVZBSUxBQkxFXTsKICAgICAgICAgICAgY29uc3QgbG9jayA9IHRoaXMuY29udHJvbFNBQltDT05UUk9MLkxPQ0tdOwogICAgICAgICAgICBpZiAobG9jayA9PT0gMCAmJiBmcmFtZXNBdmFpbGFibGUgPiAwKSB7CiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhU0FCLnN1YmFycmF5KDAsIGZyYW1lc0F2YWlsYWJsZSk7CiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xTQUJbQ09OVFJPTC5GUkFNRVNfQVZBSUxBQkxFXSA9IDA7CiAgICAgICAgICAgICAgICB0aGlzLmNvbnRyb2xTQUJbQ09OVFJPTC5XUklURV9JTkRFWF0gPSAwOwogICAgICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMCkgewogICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc0F1ZGlvKGRhdGEpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHN0YXJ0Q29udGV4dChjb250ZXh0T3B0aW9ucykgewogICAgICAgICAgICB2YXIgX2E7CiAgICAgICAgICAgIGlmICghdGhpcy5hdWRpb1Byb2Nlc3NvcikgewogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vIEF1ZGlvUHJvY2Vzc29yJyk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKHRoaXMuaXNDb250ZXh0U3RhcnRlZCkgewogICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1dlYlNvY2tldENsaWVudF0nLCAiY2FuJ3Qgc3RhcnQgY29udGV4dDogYWN0aXZlIGNvbnRleHQgZXhpc3RzIik7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5hdWRpb1Byb2Nlc3Nvci5zZXRTZW5kQXVkaW8odHJ1ZSk7CiAgICAgICAgICAgIHRoaXMuaXNDb250ZXh0U3RhcnRlZCA9IHRydWU7CiAgICAgICAgICAgIHRoaXMuYXVkaW9Db250ZXh0U3RhcnRUaW1lcy5wdXNoKHRoaXMuYXVkaW9Qcm9jZXNzb3IuZ2V0U3RyZWFtUG9zaXRpb24oKSk7CiAgICAgICAgICAgIHRoaXMud29ya2VyQ3R4LnBvc3RNZXNzYWdlKHsgdHlwZTogV29ya2VyU2lnbmFsLlJlcXVlc3RDb250ZXh0U3RhcnQgfSk7CiAgICAgICAgICAgIGxldCBvcHRpb25zID0gKF9hID0gdGhpcy5kZWZhdWx0Q29udGV4dE9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9OwogICAgICAgICAgICBpZiAoY29udGV4dE9wdGlvbnMgIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIGNvbnRleHRPcHRpb25zKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gY29udGV4dE9wdGlvbnNUb01zZyhvcHRpb25zKTsKICAgICAgICAgICAgbWVzc2FnZS5ldmVudCA9ICdzdGFydCc7CiAgICAgICAgICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7CiAgICAgICAgfQogICAgICAgIHN0b3BDb250ZXh0KCkgewogICAgICAgICAgICBpZiAoIXRoaXMuYXVkaW9Qcm9jZXNzb3IpIHsKICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdObyBBdWRpb1Byb2Nlc3NvcicpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICghdGhpcy5pc0NvbnRleHRTdGFydGVkKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdbV2ViU29ja2V0Q2xpZW50XScsICJjYW4ndCBzdG9wIGNvbnRleHQ6IG5vIGFjdGl2ZSBjb250ZXh0Iik7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5hdWRpb1Byb2Nlc3Nvci5zZXRTZW5kQXVkaW8oZmFsc2UpOwogICAgICAgICAgICB0aGlzLmlzQ29udGV4dFN0YXJ0ZWQgPSBmYWxzZTsKICAgICAgICAgICAgaWYgKHRoaXMud2Vic29ja2V0KSB7CiAgICAgICAgICAgICAgICBjb25zdCBTdG9wRXZlbnRKU09OID0gSlNPTi5zdHJpbmdpZnkoeyBldmVudDogJ3N0b3AnIH0pOwogICAgICAgICAgICAgICAgdGhpcy5zZW5kKFN0b3BFdmVudEpTT04pOwogICAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHN3aXRjaENvbnRleHQoY29udGV4dE9wdGlvbnMpIHsKICAgICAgICAgICAgaWYgKCF0aGlzLndlYnNvY2tldCkgewogICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1dlYlNvY2tldCBpcyB1bmRlZmluZWQnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIXRoaXMuaXNDb250ZXh0U3RhcnRlZCkgewogICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1dlYlNvY2tldENsaWVudF0nLCAiY2FuJ3Qgc3dpdGNoIGNvbnRleHQ6IG5vIGFjdGl2ZSBjb250ZXh0Iik7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgaWYgKChjb250ZXh0T3B0aW9ucyA9PT0gbnVsbCB8fCBjb250ZXh0T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dE9wdGlvbnMuYXBwSWQpID09PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1tXZWJTb2NrZXRDbGllbnRdJywgImNhbid0IHN3aXRjaCBjb250ZXh0OiBuZXcgYXBwIGlkIGlzIHVuZGVmaW5lZCIpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGNvbnN0IFN0b3BFdmVudEpTT04gPSBKU09OLnN0cmluZ2lmeSh7IGV2ZW50OiAnc3RvcCcgfSk7CiAgICAgICAgICAgIHRoaXMuc2VuZChTdG9wRXZlbnRKU09OKTsKICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNvbnRleHRPcHRpb25zVG9Nc2coY29udGV4dE9wdGlvbnMpOwogICAgICAgICAgICBtZXNzYWdlLmV2ZW50ID0gJ3N0YXJ0JzsKICAgICAgICAgICAgdGhpcy5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKTsKICAgICAgICB9CiAgICAgICAgY2xvc2VXZWJzb2NrZXQod2Vic29ja2V0Q29kZSA9IDEwMDUsIHJlYXNvbiA9ICdObyBTdGF0dXMgUmVjZWl2ZWQnKSB7CiAgICAgICAgICAgIGlmICh0aGlzLmRlYnVnKSB7CiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnW1dlYlNvY2tldENsaWVudF0nLCAnV2Vic29ja2V0IGNsb3NpbmcnKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAoIXRoaXMud2Vic29ja2V0KSB7CiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignV2ViU29ja2V0IGlzIHVuZGVmaW5lZCcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHRoaXMud2Vic29ja2V0LmNsb3NlKHdlYnNvY2tldENvZGUsIHJlYXNvbik7CiAgICAgICAgfQogICAgICAgIHNlbmQoZGF0YSkgewogICAgICAgICAgICBpZiAoIXRoaXMud2Vic29ja2V0KSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFdlYnNvY2tldCcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIGlmICh0aGlzLndlYnNvY2tldC5yZWFkeVN0YXRlICE9PSB0aGlzLndlYnNvY2tldC5PUEVOKSB7CiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIE9QRU4gV2Vic29ja2V0IHN0YXRlLCBidXQgZ290ICR7dGhpcy53ZWJzb2NrZXQucmVhZHlTdGF0ZX1gKTsKICAgICAgICAgICAgfQogICAgICAgICAgICB0cnkgewogICAgICAgICAgICAgICAgdGhpcy53ZWJzb2NrZXQuc2VuZChkYXRhKTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdbV2ViU29ja2V0Q2xpZW50XScsICdzZXJ2ZXIgY29ubmVjdGlvbiBlcnJvcicsIGVycm9yKTsKICAgICAgICAgICAgfQogICAgICAgIH0KICAgICAgICBzZXRDb250ZXh0T3B0aW9ucyhvcHRpb25zKSB7CiAgICAgICAgICAgIHRoaXMuZGVmYXVsdENvbnRleHRPcHRpb25zID0gb3B0aW9uczsKICAgICAgICB9CiAgICB9CiAgICBjb25zdCBjdHggPSBzZWxmOwogICAgY29uc3Qgd2Vic29ja2V0Q2xpZW50ID0gbmV3IFdlYnNvY2tldENsaWVudChjdHgpOwogICAgY3R4Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7CiAgICAgICAgc3dpdGNoIChlLmRhdGEudHlwZSkgewogICAgICAgICAgICBjYXNlIENvbnRyb2xsZXJTaWduYWwuY29ubmVjdDoKICAgICAgICAgICAgICAgIHdlYnNvY2tldENsaWVudC5jb25uZWN0KGUuZGF0YS5hcGlVcmwsIGUuZGF0YS5hdXRoVG9rZW4sIGUuZGF0YS50YXJnZXRTYW1wbGVSYXRlLCBlLmRhdGEuZGVidWcpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgQ29udHJvbGxlclNpZ25hbC5pbml0QXVkaW9Qcm9jZXNzb3I6CiAgICAgICAgICAgICAgICB3ZWJzb2NrZXRDbGllbnQuaW5pdEF1ZGlvUHJvY2Vzc29yKGUuZGF0YS5zb3VyY2VTYW1wbGVSYXRlLCBlLmRhdGEuZnJhbWVNaWxsaXMsIGUuZGF0YS5oaXN0b3J5RnJhbWVzLCBlLmRhdGEudmFkT3B0aW9ucyk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSBDb250cm9sbGVyU2lnbmFsLmFkanVzdEF1ZGlvUHJvY2Vzc29yOgogICAgICAgICAgICAgICAgd2Vic29ja2V0Q2xpZW50LmFkanVzdEF1ZGlvUHJvY2Vzc29yKGUuZGF0YS5wYXJhbXMpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgQ29udHJvbGxlclNpZ25hbC5TRVRfU0hBUkVEX0FSUkFZX0JVRkZFUlM6CiAgICAgICAgICAgICAgICB3ZWJzb2NrZXRDbGllbnQuc2V0U2hhcmVkQXJyYXlCdWZmZXJzKGUuZGF0YS5jb250cm9sU0FCLCBlLmRhdGEuZGF0YVNBQik7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSBDb250cm9sbGVyU2lnbmFsLkNMT1NFOgogICAgICAgICAgICAgICAgd2Vic29ja2V0Q2xpZW50LmNsb3NlV2Vic29ja2V0KDEwMDAsICdDbG9zZSByZXF1ZXN0ZWQgYnkgY2xpZW50Jyk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSBDb250cm9sbGVyU2lnbmFsLnN0YXJ0U3RyZWFtOgogICAgICAgICAgICAgICAgd2Vic29ja2V0Q2xpZW50LnN0YXJ0U3RyZWFtKGUuZGF0YS5zdHJlYW1PcHRpb25zKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIENvbnRyb2xsZXJTaWduYWwuc3RvcFN0cmVhbToKICAgICAgICAgICAgICAgIHdlYnNvY2tldENsaWVudC5zdG9wU3RyZWFtKCk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSBDb250cm9sbGVyU2lnbmFsLlNUQVJUX0NPTlRFWFQ6CiAgICAgICAgICAgICAgICB3ZWJzb2NrZXRDbGllbnQuc3RhcnRDb250ZXh0KGUuZGF0YS5vcHRpb25zKTsKICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICBjYXNlIENvbnRyb2xsZXJTaWduYWwuU1dJVENIX0NPTlRFWFQ6CiAgICAgICAgICAgICAgICB3ZWJzb2NrZXRDbGllbnQuc3dpdGNoQ29udGV4dChlLmRhdGEub3B0aW9ucyk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgY2FzZSBDb250cm9sbGVyU2lnbmFsLlNUT1BfQ09OVEVYVDoKICAgICAgICAgICAgICAgIHdlYnNvY2tldENsaWVudC5zdG9wQ29udGV4dCgpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgQ29udHJvbGxlclNpZ25hbC5BVURJTzoKICAgICAgICAgICAgICAgIHdlYnNvY2tldENsaWVudC5wcm9jZXNzQXVkaW8oZS5kYXRhLnBheWxvYWQpOwogICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgIGNhc2UgQ29udHJvbGxlclNpZ25hbC5zZXRDb250ZXh0T3B0aW9uczoKICAgICAgICAgICAgICAgIHdlYnNvY2tldENsaWVudC5zZXRDb250ZXh0T3B0aW9ucyhlLmRhdGEub3B0aW9ucyk7CiAgICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgICAgZGVmYXVsdDoKICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdXT1JLRVInLCBlKTsKICAgICAgICB9CiAgICB9OwogICAgZnVuY3Rpb24gY29udGV4dE9wdGlvbnNUb01zZyhjb250ZXh0T3B0aW9ucykgewogICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7CiAgICAgICAgICAgIG9wdGlvbnM6IHsKICAgICAgICAgICAgICAgIHRpbWV6b25lOiBbSW50bC5EYXRlVGltZUZvcm1hdCgpLnJlc29sdmVkT3B0aW9ucygpLnRpbWVab25lXSwKICAgICAgICAgICAgfSwKICAgICAgICB9OwogICAgICAgIGlmIChjb250ZXh0T3B0aW9ucyA9PT0gdW5kZWZpbmVkKQogICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsKICAgICAgICBtZXNzYWdlLm9wdGlvbnMudm9jYWJ1bGFyeSA9IGNvbnRleHRPcHRpb25zLnZvY2FidWxhcnk7CiAgICAgICAgbWVzc2FnZS5vcHRpb25zLnZvY2FidWxhcnlfYmlhcyA9IGNvbnRleHRPcHRpb25zLnZvY2FidWxhcnlCaWFzOwogICAgICAgIG1lc3NhZ2Uub3B0aW9ucy5zaWxlbmNlX3RyaWdnZXJlZF9zZWdtZW50YXRpb24gPSBjb250ZXh0T3B0aW9ucy5zaWxlbmNlVHJpZ2dlcmVkU2VnbWVudGF0aW9uOwogICAgICAgIGlmIChjb250ZXh0T3B0aW9ucy5ub25TdHJlYW1pbmdObHUpIHsKICAgICAgICAgICAgbWVzc2FnZS5vcHRpb25zLm5vbl9zdHJlYW1pbmdfbmx1ID0gWyd5ZXMnXTsKICAgICAgICB9CiAgICAgICAgZWxzZSB7CiAgICAgICAgICAgIG1lc3NhZ2Uub3B0aW9ucy5ub25fc3RyZWFtaW5nX25sdSA9IFsnbm8nXTsKICAgICAgICB9CiAgICAgICAgaWYgKChjb250ZXh0T3B0aW9ucyA9PT0gbnVsbCB8fCBjb250ZXh0T3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dE9wdGlvbnMudGltZXpvbmUpICE9PSB1bmRlZmluZWQpIHsKICAgICAgICAgICAgbWVzc2FnZS5vcHRpb25zLnRpbWV6b25lID0gY29udGV4dE9wdGlvbnMgPT09IG51bGwgfHwgY29udGV4dE9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHRPcHRpb25zLnRpbWV6b25lOyAvLyBvdmVycmlkZSBicm93c2VyIHRpbWV6b25lCiAgICAgICAgfQogICAgICAgIGlmIChjb250ZXh0T3B0aW9ucy5hcHBJZCAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgIG1lc3NhZ2UuYXBwSWQgPSBjb250ZXh0T3B0aW9ucy5hcHBJZDsKICAgICAgICB9CiAgICAgICAgcmV0dXJuIG1lc3NhZ2U7CiAgICB9CgogICAgZXhwb3J0cy5jb250ZXh0T3B0aW9uc1RvTXNnID0gY29udGV4dE9wdGlvbnNUb01zZzsKICAgIGV4cG9ydHNbImRlZmF1bHQiXSA9IFdlYnNvY2tldENsaWVudDsKCiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pOwoKICAgIHJldHVybiBleHBvcnRzOwoKfSkoe30pOwoK", null, false);
    WebWorkerController = class {
      constructor() {
        this.startCbs = [];
        this.stopCbs = [];
        this.onResponseCb = () => {
        };
        this.onCloseCb = () => {
        };
        this.onWebsocketMessage = (event) => {
          const response = event.data;
          switch (response.type) {
            case WorkerSignal.Opened:
              if (this.resolveInitialization != null) {
                this.resolveInitialization();
              }
              break;
            case WorkerSignal.Closed:
              this.onCloseCb({
                code: event.data.code,
                reason: event.data.reason,
                wasClean: event.data.wasClean
              });
              break;
            case WorkerSignal.AudioProcessorReady:
              if (this.resolveSourceSampleRateSet != null) {
                this.resolveSourceSampleRateSet();
              }
              break;
            case WebsocketResponseType.Started:
              this.onResponseCb(response);
              this.startCbs.forEach((cb) => {
                try {
                  cb(void 0, response.audio_context);
                } catch (e) {
                  console.error('[SpeechlyClient] Error while invoking "onStart" callback:', e);
                }
              });
              this.startCbs.length = 0;
              break;
            case WebsocketResponseType.Stopped:
              this.onResponseCb(response);
              this.stopCbs.forEach((cb) => {
                try {
                  cb(void 0, response.audio_context);
                } catch (e) {
                  console.error('[SpeechlyClient] Error while invoking "onStop" callback:', e);
                }
              });
              this.stopCbs.length = 0;
              break;
            default:
              this.onResponseCb(response);
          }
        };
        this.worker = new WorkerFactory();
        this.worker.addEventListener("message", this.onWebsocketMessage);
      }
      onResponse(cb) {
        this.onResponseCb = cb;
      }
      onClose(cb) {
        this.onCloseCb = cb;
      }
      initialize(apiUrl, authToken, targetSampleRate, debug) {
        return __awaiter(this, void 0, void 0, function* () {
          this.worker.postMessage({
            type: ControllerSignal.connect,
            apiUrl,
            authToken,
            targetSampleRate,
            debug
          });
          this.startCbs = [];
          this.stopCbs = [];
          return new Promise((resolve) => {
            this.resolveInitialization = resolve;
          });
        });
      }
      initAudioProcessor(sourceSampleRate, frameMillis, historyFrames, vadOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          this.worker.postMessage({
            type: ControllerSignal.initAudioProcessor,
            sourceSampleRate,
            frameMillis,
            historyFrames,
            vadOptions
          });
          return new Promise((resolve) => {
            this.resolveSourceSampleRateSet = resolve;
          });
        });
      }
      adjustAudioProcessor(ap) {
        this.worker.postMessage({
          type: ControllerSignal.adjustAudioProcessor,
          params: ap
        });
      }
      close() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.worker.postMessage({
              type: ControllerSignal.CLOSE,
              code: 1e3,
              message: "Client has ended the session"
            });
            resolve();
          });
        });
      }
      startStream(streamOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          this.worker.postMessage({ type: ControllerSignal.startStream, streamOptions });
        });
      }
      stopStream() {
        return __awaiter(this, void 0, void 0, function* () {
          this.worker.postMessage({ type: ControllerSignal.stopStream });
        });
      }
      startContext(options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.startCbs.push((err, id) => {
              if (err !== void 0) {
                reject(err);
              } else {
                resolve(id);
              }
            });
            this.worker.postMessage({ type: ControllerSignal.START_CONTEXT, options });
          });
        });
      }
      stopContext() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.stopCbs.push((err, id) => {
              if (err !== void 0) {
                reject(err);
              } else {
                resolve(id);
              }
            });
            this.worker.postMessage({ type: ControllerSignal.STOP_CONTEXT });
          });
        });
      }
      switchContext(options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            this.startCbs.push((err, id) => {
              if (err !== void 0) {
                reject(err);
              } else {
                resolve(id);
              }
            });
            this.worker.postMessage({ type: ControllerSignal.SWITCH_CONTEXT, options });
          });
        });
      }
      postMessage(message) {
        this.worker.postMessage(message);
      }
      sendAudio(audioChunk) {
        this.worker.postMessage({ type: ControllerSignal.AUDIO, payload: audioChunk });
      }
      setContextOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
          this.worker.postMessage({ type: ControllerSignal.setContextOptions, options });
        });
      }
    };
    LocalStorage = class {
      constructor() {
        this.storage = window.localStorage;
      }
      get(key) {
        const val = this.storage.getItem(key);
        return val;
      }
      set(key, val) {
        this.storage.setItem(key, val);
      }
      getOrSet(key, genFn) {
        let val = this.storage.getItem(key);
        if (val === null) {
          val = genFn();
          this.storage.setItem(key, val);
        }
        return val;
      }
    };
    deviceIdStorageKey = "speechly-device-id";
    authTokenKey = "speechly-auth-token";
    CloudDecoder = class {
      constructor(options) {
        var _a, _b;
        this.streamOptions = StreamDefaultOptions;
        this.activeContexts = 0;
        this.audioContexts = /* @__PURE__ */ new Map();
        this.maxReconnectAttemptCount = 10;
        this.connectAttempt = 0;
        this.connectPromise = null;
        this.cbs = [];
        this.state = DecoderState.Disconnected;
        this.handleWebsocketResponse = (response) => {
          var _a2;
          if (this.debug) {
            console.log("[Decoder]", "Received response", response);
          }
          switch (response.type) {
            case WorkerSignal.VadSignalHigh:
              this.cbs.forEach((cb) => cb.onVadStateChange.forEach((f) => f(true)));
              break;
            case WorkerSignal.VadSignalLow:
              this.cbs.forEach((cb) => cb.onVadStateChange.forEach((f) => f(false)));
              break;
            case WorkerSignal.RequestContextStart:
              this.activeContexts++;
              break;
            case WebsocketResponseType.Started: {
              const params = response.params;
              this.audioContexts.set(response.audio_context, {
                segments: /* @__PURE__ */ new Map(),
                audioStartTimeMillis: (_a2 = params === null || params === void 0 ? void 0 : params.audioStartTimeMillis) !== null && _a2 !== void 0 ? _a2 : 0
              });
              this.cbs.forEach((cb) => cb.contextStartedCbs.forEach((f) => f(response.audio_context)));
              break;
            }
            case WebsocketResponseType.Stopped: {
              this.activeContexts--;
              this.cbs.forEach((cb) => cb.contextStoppedCbs.forEach((f) => f(response.audio_context)));
              if (!this.streamOptions.preserveSegments) {
                this.audioContexts.delete(response.audio_context);
              }
              if (this.resolveStopStream !== void 0 && this.activeContexts === 0) {
                this.resolveStopStream();
              }
              break;
            }
            default:
              this.handleSegmentUpdate(response);
              break;
          }
        };
        this.handleSegmentUpdate = (response) => {
          var _a2;
          const { audio_context, segment_id, type } = response;
          let { data } = response;
          const context = this.audioContexts.get(audio_context);
          if (context === void 0) {
            console.warn("[Decoder]", "Received response for non-existent context", audio_context);
            return;
          }
          let segmentState = (_a2 = context.segments.get(segment_id)) !== null && _a2 !== void 0 ? _a2 : new SegmentState(audio_context, segment_id);
          switch (type) {
            case WebsocketResponseType.TentativeTranscript:
              data = data;
              const words = parseTentativeTranscript(data, context.audioStartTimeMillis);
              const transcript = data.transcript;
              this.cbs.forEach((cb) => cb.tentativeTranscriptCbs.forEach((f) => f(audio_context, segment_id, words, transcript)));
              segmentState = segmentState.updateTranscript(words);
              break;
            case WebsocketResponseType.Transcript:
              data = data;
              const word = parseTranscript(data, context.audioStartTimeMillis);
              this.cbs.forEach((cb) => cb.transcriptCbs.forEach((f) => f(audio_context, segment_id, word)));
              segmentState = segmentState.updateTranscript([word]);
              break;
            case WebsocketResponseType.TentativeEntities:
              data = data;
              const entities = parseTentativeEntities(data);
              this.cbs.forEach((cb) => cb.tentativeEntityCbs.forEach((f) => f(audio_context, segment_id, entities)));
              segmentState = segmentState.updateEntities(entities);
              break;
            case WebsocketResponseType.Entity:
              data = data;
              const entity = parseEntity(data);
              this.cbs.forEach((cb) => cb.entityCbs.forEach((f) => f(audio_context, segment_id, entity)));
              segmentState = segmentState.updateEntities([entity]);
              break;
            case WebsocketResponseType.TentativeIntent:
              data = data;
              const tentativeIntent = parseIntent(data, false);
              this.cbs.forEach((cb) => cb.tentativeIntentCbs.forEach((f) => f(audio_context, segment_id, tentativeIntent)));
              segmentState = segmentState.updateIntent(tentativeIntent);
              break;
            case WebsocketResponseType.Intent:
              data = data;
              const intent = parseIntent(data, true);
              this.cbs.forEach((cb) => cb.intentCbs.forEach((f) => f(audio_context, segment_id, intent)));
              segmentState = segmentState.updateIntent(intent);
              break;
            case WebsocketResponseType.SegmentEnd:
              segmentState = segmentState.finalize();
              break;
          }
          context.segments.set(segment_id, segmentState);
          this.audioContexts.set(audio_context, context);
          if (this.logSegments) {
            console.info(segmentState.toString());
          }
          this.cbs.forEach((cb) => cb.segmentChangeCbs.forEach((f) => f(segmentState.toSegment())));
        };
        this.handleWebsocketClosure = (err) => {
          if (err.code === 1e3) {
            if (this.debug) {
              console.log("[Decoder]", "Websocket closed", err);
            }
          } else {
            console.error("[Decoder]", "Websocket closed due to error", err);
            if (this.deviceId === void 0) {
              this.setState(DecoderState.Failed);
              console.error("[Decoder]", "No deviceId. Giving up reconnecting.");
              return;
            }
            this.setState(DecoderState.Disconnected);
            this.activeContexts = 0;
            this.audioContexts.clear();
            this.reconnect();
          }
        };
        this.logSegments = options.logSegments;
        this.appId = options.appId;
        this.projectId = options.projectId;
        this.sampleRate = options.sampleRate;
        this.debug = options.debug;
        if (this.appId !== void 0 && this.projectId !== void 0) {
          throw Error("[Decoder] You cannot use both appId and projectId at the same time");
        } else if (this.appId === void 0 && this.projectId === void 0) {
          throw Error("[Decoder] Either an appId or a projectId is required");
        }
        const apiUrl = options.apiUrl;
        this.apiUrl = generateWsUrl(apiUrl.replace("http", "ws") + "/ws/v1", this.sampleRate);
        this.loginUrl = `${apiUrl}/login`;
        this.storage = (_a = options.storage) !== null && _a !== void 0 ? _a : new LocalStorage();
        this.deviceId = this.storage.getOrSet(deviceIdStorageKey, v4);
        this.apiClient = new WebWorkerController();
        this.apiClient.onResponse(this.handleWebsocketResponse);
        this.apiClient.onClose(this.handleWebsocketClosure);
        if ((_b = options.connect) !== null && _b !== void 0 ? _b : true) {
          this.connect();
        }
      }
      getReconnectDelayMs(attempt) {
        return Math.pow(2, attempt) * 100;
      }
      sleep(ms) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => setTimeout(resolve, ms));
        });
      }
      connect() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.connectPromise === null) {
            this.connectPromise = (() => __awaiter(this, void 0, void 0, function* () {
              const storedToken = this.storage.get(authTokenKey);
              if (storedToken == null || !validateToken(storedToken, this.projectId, this.appId, this.deviceId)) {
                try {
                  this.authToken = yield fetchToken(this.loginUrl, this.projectId, this.appId, this.deviceId, fetch);
                  this.storage.set(authTokenKey, this.authToken);
                } catch (err) {
                  this.setState(DecoderState.Failed);
                  throw err;
                }
              } else {
                this.authToken = storedToken;
              }
              yield this.apiClient.initialize(this.apiUrl, this.authToken, this.sampleRate, this.debug);
              this.advanceState(DecoderState.Connected);
            }))();
          }
          yield this.connectPromise;
        });
      }
      adjustAudioProcessor(ap) {
        this.apiClient.adjustAudioProcessor(ap);
      }
      close() {
        return __awaiter(this, void 0, void 0, function* () {
          let error;
          try {
            yield this.apiClient.close();
          } catch (err) {
            error = err.message;
          }
          this.audioContexts.clear();
          this.activeContexts = 0;
          this.connectPromise = null;
          this.setState(DecoderState.Disconnected);
          if (error !== void 0) {
            throw Error(error);
          }
        });
      }
      startStream(streamOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.debug) {
            console.log("[Decoder]", "startStream");
          }
          this.streamOptions = streamOptions;
          this.audioContexts.clear();
          this.activeContexts = 0;
          yield this.apiClient.startStream(streamOptions);
        });
      }
      stopStream() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.debug) {
            console.log("[Decoder]", "stopStream");
          }
          yield this.apiClient.stopStream();
          yield this.waitResults();
        });
      }
      waitResults() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.activeContexts > 0) {
            const p = new Promise((resolve) => {
              this.resolveStopStream = resolve;
            });
            yield p;
          }
          this.resolveStopStream = void 0;
        });
      }
      startContext(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.state === DecoderState.Failed) {
            throw Error("[Decoder] startContext cannot be run in Failed state.");
          } else if (this.state < DecoderState.Connected) {
            yield this.connect();
          } else if (this.state > DecoderState.Connected) {
            throw Error("[Decoder] Unable to complete startContext: Expected Connected state, but was in " + stateToString(this.state) + ".");
          }
          this.setState(DecoderState.Active);
          let contextId;
          if (this.projectId != null) {
            if (options === null || options === void 0 ? void 0 : options.appId) {
              contextId = yield this.apiClient.startContext(options);
            } else {
              throw new Error("options.appId is required with project login");
            }
          } else {
            if ((options === null || options === void 0 ? void 0 : options.appId) != null && this.appId !== (options === null || options === void 0 ? void 0 : options.appId)) {
              this.setState(DecoderState.Failed);
              throw ErrAppIdChangeWithoutProjectLogin;
            }
            contextId = yield this.apiClient.startContext(options);
          }
          if (this.state < DecoderState.Active) {
            throw Error("[Decoder] Unable to complete startContext: Problem acquiring contextId");
          }
          return contextId;
        });
      }
      sendAudio(audio) {
        this.apiClient.sendAudio(audio);
      }
      stopContext(stopDelayMs) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.state === DecoderState.Failed) {
            throw Error("[Decoder] stopContext cannot be run in unrecovable error state.");
          } else if (this.state !== DecoderState.Active) {
            throw Error("[Decoder] Unable to complete stopContext: Expected Active state, but was in " + stateToString(this.state) + ".");
          }
          if (stopDelayMs > 0) {
            yield this.sleep(stopDelayMs);
          }
          const contextId = yield this.apiClient.stopContext();
          this.setState(DecoderState.Connected);
          return contextId;
        });
      }
      switchContext(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.state !== DecoderState.Active) {
            throw Error("[Decoder] Unable to complete switchContext: Expected Active state, but was in " + stateToString(this.state) + ".");
          }
          const contextId = yield this.apiClient.switchContext(options);
          return contextId;
        });
      }
      registerListener(listener) {
        this.cbs.push(listener);
      }
      initAudioProcessor(sourceSampleRate, frameMillis, historyFrames, vadOptions) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.apiClient.initAudioProcessor(sourceSampleRate, frameMillis, historyFrames, vadOptions);
        });
      }
      useSharedArrayBuffers(controlSAB, dataSAB) {
        this.apiClient.postMessage({
          type: "SET_SHARED_ARRAY_BUFFERS",
          controlSAB,
          dataSAB
        });
      }
      setContextOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.apiClient.setContextOptions(options);
        });
      }
      reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.debug) {
            console.log("[Decoder]", "Reconnecting...", this.connectAttempt);
          }
          this.connectPromise = null;
          if (this.connectAttempt < this.maxReconnectAttemptCount) {
            yield this.sleep(this.getReconnectDelayMs(this.connectAttempt++));
            yield this.connect();
          } else {
            console.error("[Decoder] Maximum reconnect count reached, giving up automatic reconnect.");
          }
        });
      }
      advanceState(newState) {
        if (this.state >= newState) {
          return;
        }
        this.setState(newState);
      }
      setState(newState) {
        if (this.state === newState) {
          return;
        }
        if (this.debug) {
          console.log("[Decoder]", stateToString(this.state), "->", stateToString(newState));
        }
        this.state = newState;
        this.cbs.forEach((cb) => {
          var _a;
          return (_a = cb.stateChangeCbs) === null || _a === void 0 ? void 0 : _a.forEach((f) => f(newState));
        });
      }
      getSegments() {
        const result = [];
        this.audioContexts.forEach((audioContext, _) => {
          audioContext.segments.forEach((segment, _2) => {
            const deepCopy = JSON.parse(JSON.stringify(segment));
            result.push(deepCopy);
          });
        });
        return result;
      }
    };
    audioworklet = `
// Indices for the Control SAB.
const CONTROL = {
  'WRITE_INDEX': 0,
  'FRAMES_AVAILABLE': 1,
  'LOCK': 2,
};

class SpeechlyProcessor extends AudioWorkletProcessor {
  constructor() {
    super();

    this._initialized = false;
    this.debug = false;
    this.port.onmessage = this._initialize.bind(this);
  }

  _initialize(event) {
    this.controlSAB = new Int32Array(event.data.controlSAB);
    this.dataSAB = new Float32Array(event.data.dataSAB);
    this.debug = event.data.debug;
    if (this.debug) {
      console.log('[BrowserClient AudioWorkletNode]', 'initializing audioworklet');
    }
    this.sharedBufferSize = this.dataSAB.length;
    this.buffer = new Float32Array(0);
    this._initialized = true;
  }

  _transferDataToSharedBuffer(data) {
    this.controlSAB[CONTROL.LOCK] = 1;
    let inputWriteIndex = this.controlSAB[CONTROL.WRITE_INDEX];
    if (this.controlSAB[CONTROL.FRAMES_AVAILABLE] > 0) {
      if (inputWriteIndex + data.length > this.sharedBufferSize) {
        // console.log('buffer overflow')
        inputWriteIndex = 0;
      }
    }
    this.dataSAB.set(data, inputWriteIndex);
    this.controlSAB[CONTROL.WRITE_INDEX] = inputWriteIndex + data.length;
    this.controlSAB[CONTROL.FRAMES_AVAILABLE] = inputWriteIndex + data.length;
    this.controlSAB[CONTROL.LOCK] = 0;
  }

  _pushData(data) {
    if (this.debug) {
      const signalEnergy = getStandardDeviation(data)
      this.port.postMessage({
        type: 'STATS',
        signalEnergy: signalEnergy,
        samples: data.length,
      });
    }

    if (this.buffer.length > this.sharedBufferSize) {
      const dataToTransfer = this.buffer.subarray(0, this.sharedBufferSize);
      this._transferDataToSharedBuffer(dataToTransfer);
      this.buffer = this.buffer.subarray(this.sharedBufferSize);
    }
    let concat = new Float32Array(this.buffer.length + data.length);
    concat.set(this.buffer);
    concat.set(data, this.buffer.length);
    this.buffer = concat;
  }

  process(inputs, outputs, parameters) {
    const inputChannelData = inputs[0][0];
    if (inputChannelData !== undefined) {
      if (this.controlSAB && this.dataSAB) {
        this._pushData(inputChannelData);
      } else {
        this.port.postMessage({
          type: 'DATA',
          frames: inputChannelData
        });
      }
    }

    return true;
  }
}

function getStandardDeviation(array) {
  const n = array.length
  const mean = array.reduce((a, b) => a + b) / n
  return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n)
}

registerProcessor('speechly-worklet', SpeechlyProcessor);
`;
    BrowserClient = class {
      constructor(customOptions) {
        var _a, _b;
        this.contextStopDelay = 250;
        this.debug = false;
        this.initialized = false;
        this.audioProcessorInitialized = false;
        this.isStreaming = false;
        this.active = false;
        this.listeningPromise = null;
        this.streamOptions = Object.assign({}, StreamDefaultOptions);
        this.stats = {
          maxSignalEnergy: 0,
          sentSamples: 0
        };
        this.decoderOptions = Object.assign(Object.assign(Object.assign({}, DecoderDefaultOptions), customOptions), { vad: customOptions.vad ? Object.assign(Object.assign({}, VadDefaultOptions), customOptions.vad) : void 0 });
        const constraints = window.navigator.mediaDevices.getSupportedConstraints();
        this.nativeResamplingSupported = constraints.sampleRate === true;
        this.isMobileSafari = iOS();
        this.isSafari = this.isMobileSafari || window.safari !== void 0;
        this.useSAB = !this.isSafari;
        this.debug = (_a = this.decoderOptions.debug) !== null && _a !== void 0 ? _a : true;
        this.callbacks = new EventCallbacks();
        this.callbacks.stateChangeCbs.addEventListener(this.handleStateChange.bind(this));
        this.callbacks.onVadStateChange.addEventListener(this.autoControlListening.bind(this));
        this.decoder = (_b = this.decoderOptions.decoder) !== null && _b !== void 0 ? _b : new CloudDecoder(this.decoderOptions);
        this.decoder.registerListener(this.callbacks);
      }
      initialize(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (this.initialized) {
            return;
          }
          this.initialized = true;
          if (this.debug) {
            console.log("[BrowserClient]", "initializing");
          }
          yield this.decoder.connect();
          try {
            const opts = {};
            if (this.nativeResamplingSupported) {
              opts.sampleRate = DefaultSampleRate;
            }
            if (window.webkitAudioContext !== void 0) {
              try {
                this.audioContext = new window.webkitAudioContext(opts);
              } catch (err) {
                if (this.debug) {
                  console.log("[BrowserClient]", "creating audioContext without samplerate conversion", err);
                }
                this.audioContext = new window.webkitAudioContext();
              }
            } else {
              this.audioContext = new window.AudioContext(opts);
              if (window.webkitAudioContext !== void 0) {
                yield this.audioContext.resume();
              }
            }
          } catch (_c) {
            throw ErrDeviceNotSupported;
          }
          if (!this.isSafari && window.AudioWorkletNode !== void 0) {
            if (this.debug) {
              console.log("[BrowserClient]", "using AudioWorkletNode");
            }
            const blob = new Blob([audioworklet], { type: "text/javascript" });
            const blobURL = window.URL.createObjectURL(blob);
            yield this.audioContext.audioWorklet.addModule(blobURL);
            this.speechlyNode = new AudioWorkletNode(this.audioContext, "speechly-worklet");
            this.speechlyNode.connect(this.audioContext.destination);
            if (this.useSAB && window.SharedArrayBuffer !== void 0) {
              if (this.debug) {
                console.log("[BrowserClient]", "using SharedArrayBuffer");
              }
              const controlSAB = new window.SharedArrayBuffer(4 * Int32Array.BYTES_PER_ELEMENT);
              const dataSAB = new window.SharedArrayBuffer(1024 * Float32Array.BYTES_PER_ELEMENT);
              this.decoder.useSharedArrayBuffers(controlSAB, dataSAB);
              this.speechlyNode.port.postMessage({
                type: "SET_SHARED_ARRAY_BUFFERS",
                controlSAB,
                dataSAB,
                debug: this.debug
              });
            } else {
              if (this.debug) {
                console.log("[BrowserClient]", "can not use SharedArrayBuffer");
              }
            }
            this.speechlyNode.port.onmessage = (event) => {
              switch (event.data.type) {
                case "STATS":
                  if (event.data.signalEnergy > this.stats.maxSignalEnergy) {
                    this.stats.maxSignalEnergy = event.data.signalEnergy;
                  }
                  this.stats.sentSamples += parseInt(event.data.samples);
                  break;
                case "DATA":
                  this.handleAudio(event.data.frames);
                  break;
              }
            };
          } else {
            if (this.debug) {
              console.log("[BrowserClient]", "using ScriptProcessorNode");
            }
            if (window.webkitAudioContext !== void 0) {
              const resampleRatio = this.audioContext.sampleRate / DefaultSampleRate;
              const bufSize = 4096 * Math.pow(2, Math.ceil(Math.log(resampleRatio) / Math.log(2)));
              this.audioProcessor = this.audioContext.createScriptProcessor(bufSize, 1, 1);
            } else {
              this.audioProcessor = this.audioContext.createScriptProcessor(void 0, 1, 1);
            }
            this.audioProcessor.connect(this.audioContext.destination);
            this.audioProcessor.addEventListener("audioprocess", (event) => {
              this.handleAudio(event.inputBuffer.getChannelData(0));
            });
          }
          if (this.debug) {
            console.log("[BrowserClient]", "audioContext sampleRate is", (_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.sampleRate);
          }
          this.streamOptions.sampleRate = (_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.sampleRate;
          yield this.decoder.initAudioProcessor(this.streamOptions.sampleRate, this.decoderOptions.frameMillis, this.decoderOptions.historyFrames, this.decoderOptions.vad);
          this.audioProcessorInitialized = true;
          if (options === null || options === void 0 ? void 0 : options.mediaStream) {
            yield this.attach(options === null || options === void 0 ? void 0 : options.mediaStream);
          }
        });
      }
      attach(mediaStream) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
          yield this.detach();
          this.stream = (_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.createMediaStreamSource(mediaStream);
          if (((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) !== "running") {
            if (this.debug) {
              console.log("[BrowserClient]", "audioContext resume required, state is", (_c = this.audioContext) === null || _c === void 0 ? void 0 : _c.state);
            }
            yield (_d = this.audioContext) === null || _d === void 0 ? void 0 : _d.resume();
          }
          if (this.speechlyNode) {
            (_e = this.stream) === null || _e === void 0 ? void 0 : _e.connect(this.speechlyNode);
          } else if (this.audioProcessor) {
            (_f = this.stream) === null || _f === void 0 ? void 0 : _f.connect(this.audioProcessor);
          } else {
            throw Error("[BrowserClient] cannot attach to mediaStream, not initialized");
          }
          yield this.autoControlStream();
        });
      }
      isActive() {
        return this.active;
      }
      start(options) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.active) {
            throw ErrAlreadyStarted;
          }
          this.active = true;
          const contextId = yield this.queueTask(() => __awaiter(this, void 0, void 0, function* () {
            yield this.initialize();
            if (!this.isStreaming) {
              yield this.startStream({ autoStarted: true });
            }
            const contextId2 = yield this.decoder.startContext(options);
            return contextId2;
          }));
          return contextId;
        });
      }
      stop(stopDelayMs = this.contextStopDelay) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.active) {
            throw ErrAlreadyStopped;
          }
          this.active = false;
          const contextId = yield this.queueTask(() => __awaiter(this, void 0, void 0, function* () {
            var _a;
            try {
              const contextId2 = yield this.decoder.stopContext(stopDelayMs);
              if (!((_a = this.decoderOptions.vad) === null || _a === void 0 ? void 0 : _a.enabled) && this.isStreaming && this.streamOptions.autoStarted) {
                yield this.stopStream();
              }
              if (this.stats.sentSamples === 0) {
                console.warn("[BrowserClient]", "audioContext contained no audio data");
              }
              return contextId2;
            } catch (err) {
              console.warn("[BrowserClient]", "stop() failed", err);
            } finally {
              this.stats.sentSamples = 0;
            }
          }));
          return contextId;
        });
      }
      setContextOptions(options) {
        return __awaiter(this, void 0, void 0, function* () {
          yield this.decoder.setContextOptions(options);
        });
      }
      adjustAudioProcessor(ap) {
        var _a;
        if (ap.vad) {
          if (this.decoderOptions.vad) {
            this.decoderOptions.vad = Object.assign(Object.assign({}, this.decoderOptions.vad), ap.vad);
          } else {
            throw Error("Unable to adjust VAD - it was not defined in the constructor");
          }
        }
        this.decoder.adjustAudioProcessor(ap);
        if ((_a = this.decoderOptions.vad) === null || _a === void 0 ? void 0 : _a.enabled) {
          this.autoControlStream();
        } else {
          if (this.active) {
            this.stop();
          }
        }
      }
      uploadAudioData(audioData, options) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.initialize();
          const audioBuffer = yield (_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.decodeAudioData(audioData);
          if (audioBuffer === void 0) {
            throw Error("Could not decode audioData");
          }
          const samples = audioBuffer.getChannelData(0);
          if (audioBuffer.numberOfChannels > 1) {
            const chan1samples = audioBuffer.getChannelData(1);
            for (let i = 0; i < samples.length; i++) {
              samples[i] = (samples[i] + chan1samples[i]) / 2;
            }
          }
          if (this.active)
            yield this.stop(0);
          if (this.isStreaming)
            yield this.stopStream();
          yield this.startStream({
            sampleRate: audioBuffer.sampleRate,
            preserveSegments: true,
            immediate: true
          });
          const vadActive = ((_b = this.decoderOptions.vad) === null || _b === void 0 ? void 0 : _b.enabled) && ((_c = this.decoderOptions.vad) === null || _c === void 0 ? void 0 : _c.controlListening);
          const chunkMillis = 1e3;
          let throttlingWaitMillis = 0;
          if (!vadActive) {
            yield this.start(options);
          } else {
            if (options)
              yield this.setContextOptions(options);
            if (this.decoderOptions.vad.signalSustainMillis >= chunkMillis) {
              const allowedContexts = 10;
              const lookbackWindowMillis = 1e4;
              const worstCaseContextsInLookback = lookbackWindowMillis / this.decoderOptions.vad.signalSustainMillis;
              const maxSpeedUp = allowedContexts / worstCaseContextsInLookback;
              throttlingWaitMillis = chunkMillis / maxSpeedUp;
            } else {
              console.warn(`Throttling disabled due to low (<= ${chunkMillis}) VAD sustain value. Server may disconnect while processing if contexts are created at high rate.`);
            }
            throttlingWaitMillis = 0;
          }
          let sendBuffer;
          const chunkSamples = Math.round(audioBuffer.sampleRate * chunkMillis / 1e3);
          for (let b = 0; b < samples.length; b += chunkSamples) {
            const e = b + chunkSamples;
            if (e > samples.length) {
              sendBuffer = samples.slice(b);
            } else {
              sendBuffer = samples.slice(b, e);
            }
            this.handleAudio(sendBuffer);
            yield this.sleep(throttlingWaitMillis);
          }
          if (!vadActive) {
            yield this.stop(0);
          }
          yield this.stopStream();
          const result = this.decoder.getSegments();
          return result;
        });
      }
      startStream(streamOptionOverrides) {
        return __awaiter(this, void 0, void 0, function* () {
          this.streamOptions = Object.assign(Object.assign(Object.assign({}, this.streamOptions), { autoStarted: false }), streamOptionOverrides);
          yield this.decoder.startStream(this.streamOptions);
          this.isStreaming = true;
        });
      }
      stopStream() {
        return __awaiter(this, void 0, void 0, function* () {
          this.isStreaming = false;
          yield this.decoder.stopStream();
        });
      }
      queueTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
          const prevTask = this.listeningPromise;
          this.listeningPromise = (() => __awaiter(this, void 0, void 0, function* () {
            yield prevTask;
            return task();
          }))();
          return this.listeningPromise;
        });
      }
      autoControlListening(vadActive) {
        var _a;
        if (this.debug) {
          console.log("[BrowserClient]", "autoControlListening", vadActive);
        }
        if ((_a = this.decoderOptions.vad) === null || _a === void 0 ? void 0 : _a.controlListening) {
          if (vadActive) {
            if (!this.active)
              this.start();
          } else {
            if (this.active)
              this.stop(0);
          }
        }
      }
      autoControlStream() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
          if (!this.audioProcessorInitialized)
            return;
          if (!this.stream)
            return;
          if (((_a = this.decoderOptions.vad) === null || _a === void 0 ? void 0 : _a.enabled) && !this.isStreaming) {
            yield this.startStream({ autoStarted: true });
            return;
          }
          if (!((_b = this.decoderOptions.vad) === null || _b === void 0 ? void 0 : _b.enabled) && this.isStreaming && this.streamOptions.autoStarted) {
            yield this.stopStream();
          }
        });
      }
      handleStateChange(decoderState) {
        switch (decoderState) {
          case DecoderState.Disconnected:
          case DecoderState.Failed:
            this.stopStream();
            break;
        }
      }
      detach() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this.active) {
            yield this.stop(0);
          }
          if (this.stream) {
            this.stream.disconnect();
            this.stream = void 0;
          }
        });
      }
      close() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
          yield this.detach();
          if (this.speechlyNode !== null) {
            (_a = this.speechlyNode) === null || _a === void 0 ? void 0 : _a.port.close();
            (_b = this.speechlyNode) === null || _b === void 0 ? void 0 : _b.disconnect();
          }
          if (this.audioProcessor !== void 0) {
            (_c = this.audioProcessor) === null || _c === void 0 ? void 0 : _c.disconnect();
          }
          yield this.decoder.close();
          this.initialized = false;
        });
      }
      sleep(ms) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => setTimeout(resolve, ms));
        });
      }
      handleAudio(array) {
        if (this.isStreaming) {
          this.stats.sentSamples += array.length;
          this.decoder.sendAudio(array);
        }
      }
      onStart(cb) {
        this.callbacks.contextStartedCbs.addEventListener(cb);
      }
      onStop(cb) {
        this.callbacks.contextStoppedCbs.addEventListener(cb);
      }
      onSegmentChange(cb) {
        this.callbacks.segmentChangeCbs.addEventListener(cb);
      }
      onTranscript(cb) {
        this.callbacks.transcriptCbs.addEventListener(cb);
      }
      onEntity(cb) {
        this.callbacks.entityCbs.addEventListener(cb);
      }
      onIntent(cb) {
        this.callbacks.intentCbs.addEventListener(cb);
      }
      onTentativeTranscript(cb) {
        this.callbacks.tentativeTranscriptCbs.addEventListener(cb);
      }
      onTentativeEntities(cb) {
        this.callbacks.tentativeEntityCbs.addEventListener(cb);
      }
      onTentativeIntent(cb) {
        this.callbacks.tentativeIntentCbs.addEventListener(cb);
      }
      onStateChange(cb) {
        this.callbacks.stateChangeCbs.addEventListener(cb);
      }
    };
  }
});

// node_modules/@speechly/speech-recognition-polyfill/dist/types.js
var require_types = __commonJS({
  "node_modules/@speechly/speech-recognition-polyfill/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SpeechRecognitionFailedError = exports.MicrophoneNotAllowedError = void 0;
    exports.MicrophoneNotAllowedError = {
      error: "not-allowed",
      message: "User did not give permission to use the microphone"
    };
    exports.SpeechRecognitionFailedError = {
      error: "audio-capture",
      message: "Speech recognition failed"
    };
  }
});

// node_modules/@speechly/speech-recognition-polyfill/dist/createSpeechRecognition.js
var require_createSpeechRecognition = __commonJS({
  "node_modules/@speechly/speech-recognition-polyfill/dist/createSpeechRecognition.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSpeechlySpeechRecognition = void 0;
    var browser_client_1 = (init_speechly_es(), __toCommonJS(speechly_es_exports));
    var types_1 = require_types();
    var createSpeechlySpeechRecognition = (appId) => {
      var _a;
      var _b;
      const browserSupportsAudioApis = typeof window !== "undefined" && ((_a = window.navigator) === null || _a === void 0 ? void 0 : _a.mediaDevices) !== void 0 && (window.AudioContext !== void 0 || window.webkitAudioContext !== void 0);
      return _b = class SpeechlySpeechRecognition {
        constructor() {
          this.clientInitialised = false;
          this.aborted = false;
          this.transcribing = false;
          this.continuous = false;
          this.interimResults = false;
          this.onresult = () => {
          };
          this.onend = () => {
          };
          this.onerror = () => {
          };
          this.start = () => __awaiter2(this, void 0, void 0, function* () {
            try {
              this.aborted = false;
              yield this.initialise();
              yield this.client.start();
              this.transcribing = true;
            } catch (e) {
              if (e === browser_client_1.ErrNoAudioConsent) {
                this.onerror(types_1.MicrophoneNotAllowedError);
              } else {
                this.onerror(types_1.SpeechRecognitionFailedError);
              }
            }
          });
          this.stop = () => __awaiter2(this, void 0, void 0, function* () {
            yield this._stop();
          });
          this.abort = () => __awaiter2(this, void 0, void 0, function* () {
            this.aborted = true;
            yield this._stop();
          });
          this.initialise = () => __awaiter2(this, void 0, void 0, function* () {
            if (!this.clientInitialised) {
              const microphone = new browser_client_1.BrowserMicrophone();
              yield microphone.initialize();
              const { mediaStream } = microphone;
              if (mediaStream === null || mediaStream === void 0) {
                throw browser_client_1.ErrDeviceNotSupported;
              }
              yield this.client.attach(mediaStream);
              this.clientInitialised = true;
            }
          });
          this._stop = () => __awaiter2(this, void 0, void 0, function* () {
            if (!this.transcribing) {
              return;
            }
            yield this.initialise();
            try {
              yield this.client.stop();
              this.transcribing = false;
              this.onend();
            } catch (e) {
            }
          });
          this.handleResult = (segment) => {
            if (this.aborted) {
              return;
            }
            if (!this.interimResults && !segment.isFinal) {
              return;
            }
            const transcript = segment.words.map((x) => x.value).filter((x) => x).join(" ");
            const results = [
              {
                0: {
                  transcript,
                  confidence: 1
                },
                isFinal: segment.isFinal
              }
            ];
            this.onresult({ results, resultIndex: 0 });
            if (!this.continuous && segment.isFinal) {
              this.abort().catch(() => {
              });
            }
          };
          this.client = new browser_client_1.BrowserClient({ appId });
          this.client.onSegmentChange(this.handleResult);
        }
      }, _b.hasBrowserSupport = browserSupportsAudioApis, _b;
    };
    exports.createSpeechlySpeechRecognition = createSpeechlySpeechRecognition;
    exports.default = exports.createSpeechlySpeechRecognition;
  }
});

// node_modules/@speechly/speech-recognition-polyfill/dist/index.js
var require_dist = __commonJS({
  "node_modules/@speechly/speech-recognition-polyfill/dist/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
          __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar(require_createSpeechRecognition(), exports);
    __exportStar(require_types(), exports);
  }
});
export default require_dist();
/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
//# sourceMappingURL=@speechly_speech-recognition-polyfill.js.map
